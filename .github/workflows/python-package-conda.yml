name: "üè¶ Java Ledger Viewer (Ultra Echo + .github Excel Auto-Discovery + LFS + Maven/Gradle + Self-Heal + TypePatch + Release)"

on:
  workflow_dispatch:
    inputs:
      ledger_path:
        description: "ÌÜµÏû• ÌååÏùº Í≤ΩÎ°ú (CSV/XLS/XLSX). ÎπÑÏö∞Î©¥ .github/ÏóêÏÑú ÏûêÎèôÌÉêÏÉâ"
        required: false
        default: ""
      from_date:
        description: "Ï°∞Ìöå ÏãúÏûëÏùº (YYYY-MM-DD)"
        required: false
        default: ""
      to_date:
        description: "Ï°∞Ìöå Ï¢ÖÎ£åÏùº (YYYY-MM-DD)"
        required: false
        default: ""
      sheet_name:
        description: "ÏóëÏÖÄ ÏãúÌä∏Î™Ö(ÏÑ†ÌÉù, ÎØ∏ÏßÄÏ†ï Ïãú Ï≤´ ÏãúÌä∏)"
        required: false
        default: ""
      create_release:
        description: "ÎπåÎìú ÏÇ∞Ï∂úÎ¨ºÎ°ú GitHub Release ÏÉùÏÑ±"
        type: boolean
        required: false
        default: false

env:
  TZ: Asia/Seoul
  LOG_DIR: .github/echo_logs
  DL_DIR: .github/echo_downloads
  ECHO_OK: "‚úÖ"
  ECHO_WARN: "‚ö†Ô∏è"
  ECHO_FAIL: "‚ùå"

permissions:
  contents: write
  actions: read

jobs:
  view-ledger:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout (with LFS)
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Ensure Git LFS (safe)
        shell: bash
        run: |
          set -Eeuo pipefail
          git lfs install
          git lfs pull || true

      - name: Setup Echo helpers
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${DL_DIR}"
          cat > /tmp/echo_helpers.sh <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          ECHO_OK="${ECHO_OK:-‚úÖ}"; ECHO_WARN="${ECHO_WARN:-‚ö†Ô∏è}"; ECHO_FAIL="${ECHO_FAIL:-‚ùå}"
          log(){ printf '%s %s\n' "$1" "$2" | tee -a "${LOG_DIR}/echo.log"; }
          echoe(){ log "${ECHO_OK}" "$*"; }
          warne(){ log "${ECHO_WARN}" "$*"; }
          faile(){ log "${ECHO_FAIL}" "$*"; }
          run(){ printf '‚ñ∂ %s\n' "$*" | tee -a "${LOG_DIR}/echo.log" ; eval "$@" 2>&1 | tee -a "${LOG_DIR}/echo.log"; }
          SH
          chmod +x /tmp/echo_helpers.sh
          source /tmp/echo_helpers.sh
          echoe "Echo helpers ready"

      # 1) pom.xml ÏóÜÏúºÎ©¥ Ï†ïÏÉÅ POM + ÏûêÎ∞î Î≥∏Î¨∏ ÏÉùÏÑ±(ÏûêÎèôÌÉêÏÉâ Ìè¨Ìï®)
      - name: Bootstrap minimal Maven project when pom.xml is missing
        if: hashFiles('**/pom.xml') == ''
        shell: bash
        run: |
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh
          echoe "pom.xml ÎØ∏Ï°¥Ïû¨ ‚Üí ÏµúÏÜå Maven ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ± (app/)"
          run mkdir -p app/src/main/java/com/example app/src/main/resources
          cat > app/pom.xml <<'POM'
          <?xml version="1.0" encoding="UTF-8"?>
          <project xmlns="http://maven.apache.org/POM/4.0.0"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
            <modelVersion>4.0.0</modelVersion>
            <groupId>com.example</groupId>
            <artifactId>bank-ledger</artifactId>
            <version>1.0.0</version>
            <properties>
              <maven.compiler.source>21</maven.compiler.source>
              <maven.compiler.target>21</maven.compiler.target>
              <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            </properties>
            <dependencies>
              <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-csv</artifactId>
                <version>1.11.0</version>
              </dependency>
              <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>5.2.5</version>
              </dependency>
              <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>5.2.5</version>
              </dependency>
              <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.14.0</version>
              </dependency>
            </dependencies>
            <build>
              <plugins>
                <plugin>
                  <groupId>org.apache.maven.plugins</groupId>
                  <artifactId>maven-compiler-plugin</artifactId>
                  <version>3.13.0</version>
                  <configuration><release>21</release></configuration>
                </plugin>
                <plugin>
                  <groupId>org.apache.maven.plugins</groupId>
                  <artifactId>maven-shade-plugin</artifactId>
                  <version>3.5.3</version>
                  <executions>
                    <execution>
                      <phase>package</phase>
                      <goals><goal>shade</goal></goals>
                      <configuration>
                        <createDependencyReducedPom>false</createDependencyReducedPom>
                        <transformers>
                          <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                            <mainClass>com.example.BankLedger</mainClass>
                          </transformer>
                        </transformers>
                      </configuration>
                    </execution>
                  </executions>
                </plugin>
              </plugins>
            </build>
          </project>
          POM

          # Ï¥àÍ∏∞ Java Î≥∏Î¨∏(Ïù¥ÌõÑ Ìå®Ïπò Ïä§ÌÖùÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å ÎçÆÏñ¥ÏîÄ)
          cat > app/src/main/java/com/example/BankLedger.java <<'JAVA'
          package com.example;

          import org.apache.commons.csv.CSVFormat;
          import org.apache.commons.csv.CSVParser;
          import org.apache.commons.csv.CSVRecord;
          import org.apache.poi.hssf.usermodel.HSSFWorkbook;
          import org.apache.poi.ss.usermodel.*;
          import org.apache.poi.xssf.usermodel.XSSFWorkbook;

          import java.io.*;
          import java.nio.charset.StandardCharsets;
          import java.nio.file.*;
          import java.time.LocalDate;
          import java.time.format.DateTimeFormatter;
          import java.util.*;
          import java.util.stream.Stream;

          public class BankLedger {
              record Row(LocalDate date, String time, String type, long amount, String memo, Long balance, String account){}

              static final DateTimeFormatter[] DATE_FMTS = new DateTimeFormatter[]{
                      DateTimeFormatter.ofPattern("yyyy-MM-dd"),
                      DateTimeFormatter.ofPattern("yyyy.M.d"),
                      DateTimeFormatter.ofPattern("yyyy/M/d")
              };

              public static void main(String[] args) throws Exception {
                  System.out.println("Bootstrap placeholder ‚Äî Îã§Ïùå Ìå®Ïπò Ïä§ÌÖùÏóêÏÑú Î≥∏Î¨∏ ÍµêÏ≤¥Îê®");
              }
          }
          JAVA

          echo "POM_PATH=app/pom.xml" >> "$GITHUB_ENV"

      # 2) (Ïô∏Î∂Ä/Í∏∞Ï°¥ POM Î∞©Ïñ¥) shade <transformer> ÌÉúÍ∑∏ ÏûêÎèô ÏπòÏú†
      - name: Self-heal POM shade <transformer> tag if broken
        shell: bash
        run: |
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh
          POM_PATH="${POM_PATH:-}"
          if [[ -z "${POM_PATH}" ]]; then
            POM_PATH="$(find . -type f -name pom.xml -not -path '*/.git/*' | head -n1 || true)"
          fi
          if [[ -z "${POM_PATH}" ]]; then
            warne "POM ÎØ∏Î∞úÍ≤¨ ‚Üí Self-heal Ïä§ÌÇµ"; exit 0
          fi
          NEED_FIX="$(
            awk '
              /<transformers>/ {inT=1}
              inT && /<\/transformers>/ { if (count==0) print "MISSING"; inT=0; count=0 }
              inT && /<transformer[ >]/ { count++ }
            ' "${POM_PATH}" || true
          )"
          if [[ "${NEED_FIX:-}" == "MISSING" ]]; then
            awk '
              /<transformers>/ {print; inT=1; next}
              inT && /<\/transformers>/ {print "                    </transformer>"; print; inT=0; next}
              {print}
            ' "${POM_PATH}" > "${POM_PATH}.fixed"
            mv "${POM_PATH}.fixed" "${POM_PATH}"
            echo "‚úÖ POM transformer ÌÉúÍ∑∏ ÏûêÎèô Î≥¥Ï†ï ÏôÑÎ£å"
          else
            echo "‚úÖ POM transformer ÌÉúÍ∑∏ Ï†ïÏÉÅ"
          fi

      # 3) POI Row ÌÉÄÏûÖ Ï∂©Îèå Ìå®Ïπò(Record Row ‚Üí LedgerRow, ÌíÄÎÑ§ÏûÑ ÏÇ¨Ïö©)
      - name: Patch BankLedger.java (fix POI Row clash + full implementation)
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > app/src/main/java/com/example/BankLedger.java <<'JAVA'
          package com.example;

          import org.apache.commons.csv.CSVFormat;
          import org.apache.commons.csv.CSVParser;
          import org.apache.commons.csv.CSVRecord;
          import org.apache.poi.hssf.usermodel.HSSFWorkbook;
          import org.apache.poi.ss.usermodel.*;
          import org.apache.poi.xssf.usermodel.XSSFWorkbook;

          import java.io.*;
          import java.nio.charset.StandardCharsets;
          import java.nio.file.*;
          import java.time.LocalDate;
          import java.time.format.DateTimeFormatter;
          import java.util.*;
          import java.util.stream.Stream;

          public class BankLedger {
              record LedgerRow(LocalDate date, String time, String type, long amount, String memo, Long balance, String account){}

              static final DateTimeFormatter[] DATE_FMTS = new DateTimeFormatter[]{
                      DateTimeFormatter.ofPattern("yyyy-MM-dd"),
                      DateTimeFormatter.ofPattern("yyyy.M.d"),
                      DateTimeFormatter.ofPattern("yyyy/M/d")
              };

              public static void main(String[] args) throws Exception {
                  String path = argOrEnv(args, 0, "LEDGER_PATH", "");
                  String from = argOrEnv(args, 1, "FROM_DATE", "");
                  String to   = argOrEnv(args, 2, "TO_DATE", "");
                  String sheetName = System.getenv().getOrDefault("SHEET_NAME", "");

                  if (path.isBlank()) {
                      Optional<Path> found = autoDiscover();
                      if (found.isPresent()) {
                          path = found.get().toString();
                          System.out.println("üîé Auto-discovered ledger: " + path);
                      } else {
                          System.out.println("‚ö†Ô∏è .github/ ÎÇ¥ ÌÜµÏû• ÌååÏùºÏùÑ Ï∞æÏßÄ Î™ªÌï¥ ÏÉòÌîå CSV ÏÉùÏÑ±: data/sample_ledger.csv");
                          Path p = Paths.get("data"); Files.createDirectories(p);
                          Path csv = p.resolve("sample_ledger.csv");
                          String sample = String.join("\n", List.of(
                                  "date,time,type,amount,memo,balance,account",
                                  "2025-10-11,16:36:58,Ï≤¥ÌÅ¨Ïπ¥Îìú,10860,Google handj,1673419,ÏõêÏã†Ìïú",
                                  "2025-10-09,14:15:58,Ï≤¥ÌÅ¨Ïπ¥Îìú,53692,Google handj,190880,ÏõêÏã†Ìïú",
                                  "2025-10-09,12:41:23,Ï≤¥ÌÅ¨Ïπ¥Îìú,2682,Google Pokemon,144572,ÏõêÏã†Ìïú",
                                  "2025-10-08,15:40:43,Ï≤¥ÌÅ¨Ïπ¥Îìú,10731,Google handj,179288,ÏõêÏã†Ìïú",
                                  "2025-10-08,14:52:20,Ï≤¥ÌÅ¨Ïπ¥Îìú,32222,Google handj,190019,ÏõêÏã†Ìïú"
                          ));
                          Files.writeString(csv, sample, StandardCharsets.UTF_8);
                          path = csv.toString();
                      }
                  }

                  LocalDate fromDate = parseDateOrNull(from);
                  LocalDate toDate   = parseDateOrNull(to);

                  List<LedgerRow> rows;
                  String lower = path.toLowerCase(Locale.ROOT);
                  if (lower.endsWith(".csv")) {
                      rows = readCsv(path);
                  } else if (lower.endsWith(".xlsx") || lower.endsWith(".xls")) {
                      rows = readExcel(path, sheetName);
                  } else {
                      System.out.println("‚ùå ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌôïÏû•Ïûê: " + path);
                      return;
                  }

                  rows = filterByDate(rows, fromDate, toDate);

                  printTable(rows);

                  long totalOut = rows.stream().mapToLong(r -> r.amount).sum();
                  Long lastBalance = rows.stream().filter(r -> r.balance != null).reduce((a,b)->b).map(r->r.balance).orElse(null);

                  System.out.println();
                  System.out.println("==== ÏöîÏïΩ ====");
                  System.out.printf("Í±∞Îûò Í±¥Ïàò  : %,d%n", rows.size());
                  System.out.printf("Ï¥ù Ï∂úÍ∏àÌï©Í≥Ñ: %,dÏõê (amount Ìï©)%n", totalOut);
                  if (lastBalance != null) {
                      System.out.printf("ÎßàÏßÄÎßâ ÏûîÏï°: %,dÏõê%n", lastBalance);
                  }
              }

              // .github ÏµúÏã† ÌååÏùº ÏûêÎèôÌÉêÏÉâ: xlsx ‚Üí xls ‚Üí csv
              static Optional<Path> autoDiscover() {
                  List<String> patterns = List.of(".github/**/*.xlsx", ".github/**/*.xls", ".github/**/*.csv");
                  return patterns.stream().map(BankLedger::globLatest).filter(Objects::nonNull).findFirst();
              }

              static Path globLatest(String pattern) {
                  try {
                      Path root = Paths.get(".");
                      try (Stream<Path> s = Files.find(root, Integer.MAX_VALUE,
                              (p, attr) -> p.toString().replace('\\','/').matches(globToRegex(pattern)) && attr.isRegularFile())) {
                          return s.max(Comparator.comparingLong(p -> p.toFile().lastModified())).orElse(null);
                      }
                  } catch (Exception ignore) { return null; }
              }

              static String globToRegex(String glob) {
                  String g = glob.replace(".", "\\.")
                          .replace("**/", "(.*/)?")
                          .replace("**", ".*")
                          .replace("*", "[^/]*")
                          .replace("?", ".");
                  return "^" + g + "$";
              }

              static String argOrEnv(String[] args, int idx, String env, String def) {
                  if (args.length > idx && args[idx] != null && !args[idx].isBlank()) return args[idx];
                  return System.getenv().getOrDefault(env, def);
              }

              static LocalDate parseDateOrNull(String s) {
                  if (s == null || s.isBlank()) return null;
                  for (var fmt: DATE_FMTS) { try { return LocalDate.parse(s.trim(), fmt); } catch (Exception ignore) {} }
                  try { return LocalDate.parse(s.trim()); } catch (Exception ignore) {}
                  return null;
              }

              static List<LedgerRow> readCsv(String path) throws IOException {
                  try (Reader in = Files.newBufferedReader(Paths.get(path), StandardCharsets.UTF_8)) {
                      CSVParser p = CSVFormat.DEFAULT.builder().setHeader().setSkipHeaderRecord(true).setTrim(true).build().parse(in);
                      List<LedgerRow> out = new ArrayList<>();
                      for (CSVRecord r: p) {
                          LocalDate d = parseDateOrNull(r.get("date"));
                          String time = getSafe(r, "time");
                          String type = getSafe(r, "type");
                          long amount = parseLongSafe(getSafe(r, "amount"));
                          String memo = getSafe(r, "memo");
                          Long bal = parseLongSafeNullable(getSafe(r, "balance"));
                          String account = getSafe(r, "account");
                          if (d != null) out.add(new LedgerRow(d,time,type,amount,memo,bal,account));
                      }
                      return out;
                  }
              }

              static List<LedgerRow> readExcel(String path, String sheetName) throws IOException {
                  try (InputStream is = Files.newInputStream(Paths.get(path))) {
                      Workbook wb = path.toLowerCase(Locale.ROOT).endsWith(".xlsx") ? new XSSFWorkbook(is) : new HSSFWorkbook(is);
                      Sheet sheet = (sheetName != null && !sheetName.isBlank()) ? wb.getSheet(sheetName) : wb.getSheetAt(0);

                      Map<String,Integer> idx = new HashMap<>();
                      java.util.Iterator<org.apache.poi.ss.usermodel.Row> it = sheet.rowIterator();
                      if (!it.hasNext()) return List.of();
                      org.apache.poi.ss.usermodel.Row hr = it.next();
                      for (Cell c: hr) {
                          c.setCellType(CellType.STRING);
                          idx.put(c.getStringCellValue().toLowerCase(Locale.ROOT), c.getColumnIndex());
                      }

                      List<LedgerRow> out = new ArrayList<>();
                      while (it.hasNext()) {
                          org.apache.poi.ss.usermodel.Row rr = it.next();
                          LocalDate d = parseDateOrNull(cellStr(rr, idx.getOrDefault("date",-1)));
                          if (d == null) continue;
                          String time = cellStr(rr, idx.getOrDefault("time",-1));
                          String type = cellStr(rr, idx.getOrDefault("type",-1));
                          long amount = parseLongSafe(cellStr(rr, idx.getOrDefault("amount",-1)));
                          String memo = cellStr(rr, idx.getOrDefault("memo",-1));
                          Long bal = parseLongSafeNullable(cellStr(rr, idx.getOrDefault("balance",-1)));
                          String account = cellStr(rr, idx.getOrDefault("account",-1));
                          out.add(new LedgerRow(d,time,type,amount,memo,bal,account));
                      }
                      wb.close();
                      return out;
                  }
              }

              static String cellStr(org.apache.poi.ss.usermodel.Row r, int cidx) {
                  if (cidx < 0) return "";
                  Cell c = r.getCell(cidx);
                  if (c == null) return "";
                  return switch (c.getCellType()) {
                      case STRING -> c.getStringCellValue();
                      case NUMERIC -> DateUtil.isCellDateFormatted(c)
                              ? c.getLocalDateTimeCellValue().toLocalDate().toString()
                              : String.valueOf(Math.round(c.getNumericCellValue()));
                      case BOOLEAN -> String.valueOf(c.getBooleanCellValue());
                      default -> "";
                  };
              }

              static String getSafe(CSVRecord r, String key) { try { return r.get(key); } catch (Exception e) { return ""; } }
              static long parseLongSafe(String s) {
                  if (s == null) return 0L;
                  String t = s.replaceAll("[^0-9-]", "");
                  if (t.isBlank() || t.equals("-")) return 0L;
                  try { return Long.parseLong(t); } catch (Exception e) { return 0L; }
              }
              static Long parseLongSafeNullable(String s) {
                  String t = (s==null) ? "" : s.replaceAll("[^0-9-]", "");
                  if (t.isBlank() || t.equals("-")) return null;
                  try { return Long.parseLong(t); } catch (Exception e) { return null; }
              }

              static List<LedgerRow> filterByDate(List<LedgerRow> in, LocalDate from, LocalDate to) {
                  if (from == null && to == null) return in;
                  List<LedgerRow> out = new ArrayList<>();
                  for (LedgerRow r: in) {
                      boolean ok = true;
                      if (from != null && r.date.isBefore(from)) ok = false;
                      if (to != null && r.date.isAfter(to)) ok = false;
                      if (ok) out.add(r);
                  }
                  return out;
              }

              static void printTable(List<LedgerRow> rows) {
                  System.out.println("date       | time     | type   | amount  | memo             | balance   | account");
                  System.out.println("-----------+----------+--------+---------+------------------+-----------+--------");
                  for (LedgerRow r: rows) {
                      System.out.printf("%-10s | %-8s | %-6s | %8s | %-16s | %9s | %s%n",
                              r.date, nv(r.time), nv(r.type), fmt(r.amount), nv(r.memo),
                              r.balance==null? "-" : fmt(r.balance), nv(r.account));
                  }
              }
              static String nv(String s){ return (s==null||s.isBlank())?"-":s; }
              static String fmt(long v){ return String.format("%,d", v); }
          }
          JAVA

      # 4) JDK/Ï∫êÏãú
      - name: Setup Java (Temurin 21 + Maven cache if pom exists)
        if: hashFiles('**/pom.xml') != ''
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Setup Gradle cache (if Gradle only)
        if: hashFiles('**/pom.xml') == '' && (hashFiles('**/build.gradle') != '' || hashFiles('**/build.gradle.kts') != '')
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: gradle

      # 5) Build (Maven ÎòêÎäî Gradle ÏûêÎèô Í∞êÏßÄ)
      - name: Build (auto-detect Maven/Gradle; include untracked)
        shell: bash
        run: |
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh

          POM_PATH="${POM_PATH:-}"
          if [[ -z "${POM_PATH}" ]]; then
            POM_PATH="$(find . -type f -name pom.xml -not -path '*/.git/*' | head -n1 || true)"
          fi

          if [[ -n "${POM_PATH}" ]]; then
            echo "Detected pom: ${POM_PATH}"
            WORKDIR="$(dirname "${POM_PATH}")"
            run mvn -B -q -DskipTests -f "${POM_PATH}" package
            JAR="$(ls -1 "${WORKDIR}"/target/*-shaded.jar 2>/dev/null | head -n1 || true)"
            if [[ -z "${JAR}" ]]; then
              JAR="$(ls -1 "${WORKDIR}"/target/*jar-with-dependencies.jar 2>/dev/null | head -n1 || true)"
            fi
            if [[ -z "${JAR}" ]]; then
              faile "Ïã§Ìñâ JARÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§ (shade ÏÇ∞Ï∂úÎ¨º ÏóÜÏùå)."
              ls -al "${WORKDIR}/target" || true
              exit 1
            fi
            echo "JAR=${JAR}" >> "$GITHUB_ENV"
          else
            if [[ -f gradlew || -f build.gradle || -f build.gradle.kts ]]; then
              if [[ -f gradlew ]]; then
                run chmod +x gradlew
                if ./gradlew tasks | grep -q '^shadowJar'; then
                  run ./gradlew -q shadowJar
                  JAR="$(ls -1 build/libs/*-all.jar 2>/dev/null | head -n1 || true)"
                  [[ -z "$JAR" ]] && JAR="$(ls -1 build/libs/*-shadow.jar 2>/dev/null | head -n1 || true)"
                else
                  run ./gradlew -q build
                  JAR="$(ls -1 build/libs/*-all.jar 2>/dev/null | head -n1 || true)"
                  [[ -z "$JAR" ]] && JAR="$(ls -1 build/libs/*-shadow.jar 2>/dev/null | head -n1 || true)"
                  [[ -z "$JAR" ]] && JAR="$(ls -1 build/libs/*.jar 2>/dev/null | head -n1 || true)"
                fi
              else
                run sudo apt-get update -y
                run sudo apt-get install -y gradle || true
                run gradle -q build
                JAR="$(ls -1 build/libs/*.jar 2>/dev/null | head -n1 || true)"
              fi

              if [[ -z "${JAR:-}" ]]; then
                faile "Gradle JARÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."
                ls -al build/libs || true
                exit 1
              fi
              echo "JAR=${JAR}" >> "$GITHUB_ENV"
            else
              faile "pom.xml/Gradle ÎπåÎìú ÌååÏùºÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."
              find . -maxdepth 4 -type f \( -name pom.xml -o -name build.gradle -o -name build.gradle.kts \) -print || true
              exit 1
            fi
          fi

      # 6) Run Viewer
      - name: Run viewer (java -jar)
        shell: bash
        env:
          LEDGER_PATH: ${{ inputs.ledger_path }}
          FROM_DATE: ${{ inputs.from_date }}
          TO_DATE: ${{ inputs.to_date }}
          SHEET_NAME: ${{ inputs.sheet_name }}
        run: |
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh
          echo "LEDGER_PATH=${LEDGER_PATH:-'(ÎπàÍ∞í: .github/ ÏûêÎèôÌÉêÏÉâ)'}"
          echo "FROM_DATE=${FROM_DATE}"
          echo "TO_DATE=${TO_DATE}"
          echo "SHEET_NAME=${SHEET_NAME}"
          test -n "${JAR:-}" || { faile "JAR ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§."; exit 1; }
          run java -jar "${JAR}" "${LEDGER_PATH:-}" "${FROM_DATE:-}" "${TO_DATE:-}"

      # 7) (ÏòµÏÖò) Î¶¥Î¶¨Ï¶à ÏÉùÏÑ±
      - name: Create GitHub Release (optional)
        if: ${{ inputs.create_release == true }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "ledger-${{ github.run_id }}"
          name: "Ledger Viewer Build ${{ github.run_id }}"
          draft: false
          prerelease: false
          files: |
            ${{ env.JAR }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 8) ÏïÑÌã∞Ìå©Ìä∏ ÏóÖÎ°úÎìú
      - name: Upload artifacts (logs + jars + discovered files)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ledger-artifacts-${{ github.run_id }}
          path: |
            ${LOG_DIR}
            ${DL_DIR}
            **/target/*.jar
            build/libs/*.jar
            data/*.csv
            .github/**/*.xlsx
            .github/**/*.xls
            .github/**/*.csv
          if-no-files-found: ignore
