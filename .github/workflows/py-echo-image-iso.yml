name: "🐍 PyPkg + Echo/CopyPlan + Docker Image + ISO + Push + Release + Deploy + QA-Matrix + Caches"

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "파이썬 패키지 이름 (PEP 8 소문자, 하이픈/점 금지)"
        required: true
        default: "mypkg"
      package_version:
        description: "패키지 버전"
        required: true
        default: "0.1.0"
      dirs_count:
        description: "대량 생성 디렉토리 개수"
        required: true
        default: "500"
      iso_label:
        description: "ISO 볼륨 라벨(영문/숫자/언더스코어)"
        required: true
        default: "ECHO_ISO"
      inject_info_json:
        description: "ISO 주입 JSON"
        required: false
        default: "{\"env\":\"dev\",\"team\":\"finops\"}"
      metadata_json:
        description: "패키지 메타(JSON)"
        required: false
        default: "{\"author_name\":\"Your Name\",\"author_email\":\"you@example.com\",\"license_name\":\"MIT\"}"
      image_ref:
        description: "Docker 이미지 참조(이름:태그)"
        required: true
        default: "mypkg-app:latest"
      build_docker:
        description: "Docker 이미지 빌드/저장 수행"
        required: true
        type: boolean
        default: true
      copy_plan_json:
        description: "디렉토리 복사 계획(JSON)"
        required: false
        default: "{\"plans\":[{\"src\":\"samples\",\"dest_rel\":\"extra/samples\",\"include_globs\":[\"**/*\"],\"exclude_globs\":[\"**/.git/**\",\"**/.github/**\"],\"max_mb\":100,\"include_in_iso\":true,\"required\":false}]}"
      advanced_json:
        description: "확장 설정(JSON)"
        required: false
        default: "{\"packaging\":{\"mode\":\"pip\"},\"ghcr\":{\"enable\":false},\"dockerhub\":{\"enable\":false},\"release\":{\"enable\":false},\"server\":{\"enable\":false}}"

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write   # (키리스 cosign용 OIDC 토큰)

concurrency:
  group: pypkg-echo-${{ github.ref }}
  cancel-in-progress: true

env:
  TZ: Asia/Seoul
  LOG_DIR: .github/echo_logs
  ECHO_OK: "✅"
  ECHO_WARN: "⚠️"
  ECHO_FAIL: "❌"
  DOCKER_BUILDKIT: "1"
  LC_ALL: C.UTF-8
  LANG: C.UTF-8

jobs:
  # ────────────────────────────────────────────────────────────────────────────
  # ⓵ QA 매트릭스(3.9~3.12) : 린트/타입/커버리지 -> 리포트/아티팩트
  # ────────────────────────────────────────────────────────────────────────────
  qa-matrix:
    strategy:
      fail-fast: false
      matrix:
        python: ["3.9", "3.10", "3.11", "3.12"]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Global echo helpers
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "$LOG_DIR"
          cat > "$GITHUB_WORKSPACE/.bashenv" <<'SH'
          ECHO_OK="${ECHO_OK:-✅}"; ECHO_WARN="${ECHO_WARN:-⚠️}"; ECHO_FAIL="${ECHO_FAIL:-❌}"
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"; mkdir -p "$LOG_DIR"
          SAFE_LOG="${SAFE_LOG:-${LOG_DIR}/qa-$(date +%Y%m%d%H%M%S).log}"
          echoe(){ printf '%s %s\n' "$ECHO_OK" "$*"; }
          warn(){  printf '%s %s\n' "$ECHO_WARN" "$*"; }
          fail(){  printf '%s %s\n' "$ECHO_FAIL" "$*"; }
          logf(){  printf '%s\n' "$*" | tee -a "$SAFE_LOG"; }
          SH
          echo "BASH_ENV=$GITHUB_WORKSPACE/.bashenv" >> "$GITHUB_ENV"
          bash -lc 'echoe "[QA] helpers loaded"; logf "[QA] ready"'

      - name: Setup Python (${{ matrix.python }})
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      - name: Prep wheelhouse + cache
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p .pip-wheelhouse
          printf "build\npytest\nmypy\nruff\n" > .req.txt
          pip wheel -w .pip-wheelhouse -r .req.txt || true
          echo "✅ wheelhouse prebuilt (best-effort)"

      - name: Cache wheelhouse
        uses: actions/cache@v4
        with:
          path: .pip-wheelhouse
          key: wheelhouse-${{ runner.os }}-${{ matrix.python }}-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            wheelhouse-${{ runner.os }}-${{ matrix.python }}-
            wheelhouse-${{ runner.os }}-

      - name: Install QA deps (prefer wheelhouse)
        shell: bash
        run: |
          set -Eeuo pipefail
          if ls .pip-wheelhouse/*.whl >/dev/null 2>&1; then
            pip install --no-index --find-links .pip-wheelhouse build pytest mypy ruff
            echo "✅ installed from wheelhouse"
          else
            pip install build pytest mypy ruff
            echo "⚠️ wheelhouse empty; installed online"
          fi

      - name: Generate minimal package skeleton for QA
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name || 'mypkg' }}"
          V="${{ github.event.inputs.package_version || '0.1.0' }}"
          ROOT="workspace/${P}"
          PKG_DIR="$ROOT/src/${P}"
          TEST_DIR="$ROOT/tests"
          mkdir -p "$PKG_DIR" "$TEST_DIR"
          cat > "$PKG_DIR/__init__.py" <<PY
          __all__ = ["hello"]
          __version__ = "${V}"
          def hello(name: str = "World") -> str:
              return f"Hello, {name}!"
          PY
          cat > "$TEST_DIR/test_hello.py" <<PY
          import importlib, os, sys
          here = os.path.dirname(__file__)
          root = os.path.abspath(os.path.join(here, "..", "src"))
          if root not in sys.path: sys.path.insert(0, root)
          m = importlib.import_module("${P}")
          def test_hello():
              assert m.hello("Echo") == "Hello, Echo!"
          PY
          echo "✅ QA skeleton ready at $ROOT"

      - name: Lint & Type check (ruff/mypy)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name || 'mypkg' }}"
          ruff check "workspace/${P}"
          mypy "workspace/${P}/src" || { echo "⚠️ mypy warnings (not failing)"; }

      - name: Test with coverage (matrix)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name || 'mypkg' }}"
          cd "workspace/${P}"
          mkdir -p ../test-results
          pytest -q --junitxml=../test-results/junit-${{ matrix.python }}.xml \
                 --cov="${P}" --cov-report=xml:../test-results/coverage-${{ matrix.python }}.xml
          echo "✅ pytest ok (${{ matrix.python }})"

      - name: Upload QA artifacts
        uses: actions/upload-artifact@v4
        with:
          name: qa-reports-${{ github.run_id }}-${{ matrix.python }}
          path: |
            .github/echo_logs/**
            workspace/**/test-results/*.xml
          if-no-files-found: warn
          retention-days: 7

      - name: Cleanup caches (QA)
        if: ${{ always() }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker system prune -af || true
          sudo rm -rf /var/lib/apt/lists/* || true
          echo "✅ QA cleanup done"

  # ────────────────────────────────────────────────────────────────────────────
  # ⓶ 메인 파이프라인
  # ────────────────────────────────────────────────────────────────────────────
  all-in-one:
    needs: [qa-matrix]
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Global echo helpers (persist across steps)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "$LOG_DIR"
          cat > "$GITHUB_WORKSPACE/.bashenv" <<'SH'
          ECHO_OK="${ECHO_OK:-✅}"; ECHO_WARN="${ECHO_WARN:-⚠️}"; ECHO_FAIL="${ECHO_FAIL:-❌}"
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"; mkdir -p "$LOG_DIR"
          SAFE_LOG="${SAFE_LOG:-${LOG_DIR}/run-$(date +%Y%m%d%H%M%S).log}"
          echoe(){ printf '%s %s\n' "$ECHO_OK" "$*"; }
          warn(){  printf '%s %s\n' "$ECHO_WARN" "$*"; }
          fail(){  printf '%s %s\n' "$ECHO_FAIL" "$*"; }
          logf(){  printf '%s\n' "$*" | tee -a "$SAFE_LOG"; }
          SH
          echo "BASH_ENV=$GITHUB_WORKSPACE/.bashenv" >> "$GITHUB_ENV"
          bash -lc 'echoe "helpers loaded"; logf "helpers ready"'

      - name: Better fail trap (tail last logs on error)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "❌ Failed at line $LINENO"; tail -n 200 ${LOG_DIR}/run-* 2>/dev/null || true' ERR
          echo "✅ trap ready"

      - name: Install toolchain (Python, ISO, copy, deploy)
        shell: bash
        run: |
          set -Eeuo pipefail
          logf "Installing build/copy/deploy tools"
          sudo apt-get update -y
          sudo apt-get install -y python3 python3-venv python3-pip python3-setuptools python3-wheel \
              git jq rsync xorriso genisoimage dosfstools openssh-client
          python3 --version | tee -a "$LOG_DIR/python.txt"
          pip3 --version | tee -a "$LOG_DIR/pip.txt"
          rsync --version | head -n1 | tee -a "$LOG_DIR/rsync.txt"
          logf "Installed: xorriso/genisoimage/jq/rsync/ssh"

      - name: Parse inputs (metadata_json, image_ref, copy_plan_json, advanced_json)
        id: parse
        shell: bash
        run: |
          set -Eeuo pipefail
          MJ='${{ github.event.inputs.metadata_json }}'
          A_NAME=$(printf '%s' "$MJ" | jq -r '.author_name // "Your Name"')
          A_EMAIL=$(printf '%s' "$MJ" | jq -r '.author_email // "you@example.com"')
          L_NAME=$(printf '%s' "$MJ" | jq -r '.license_name // "MIT"')
          IMG='${{ github.event.inputs.image_ref }}'
          if [[ "$IMG" == *:* ]]; then IMG_NAME="${IMG%%:*}"; IMG_TAG="${IMG##*:}"; else IMG_NAME="$IMG"; IMG_TAG="latest"; fi
          CP='${{ github.event.inputs.copy_plan_json }}'
          printf '%s' "$CP" | jq . >/dev/null
          ADV='${{ github.event.inputs.advanced_json }}'
          printf '%s' "$ADV" | jq . >/dev/null
          PKG_MODE=$(printf '%s' "$ADV" | jq -r '.packaging.mode // "pip"')
          GHCR_ENABLE=$(printf '%s' "$ADV" | jq -r '.ghcr.enable // false')
          GHCR_REPO=$(printf '%s' "$ADV" | jq -r '.ghcr.repo // ""')
          GHCR_TAG=$(printf '%s' "$ADV" | jq -r '.ghcr.tag // ""')
          DH_ENABLE=$(printf '%s' "$ADV" | jq -r '.dockerhub.enable // false')
          DH_REPO=$(printf '%s' "$ADV" | jq -r '.dockerhub.repo // ""')
          DH_TAG=$(printf '%s' "$ADV" | jq -r '.dockerhub.tag // ""')
          REL_ENABLE=$(printf '%s' "$ADV" | jq -r '.release.enable // false')
          REL_TAG=$(printf '%s' "$ADV" | jq -r '.release.tag // ""')
          REL_DRAFT=$(printf '%s' "$ADV" | jq -r '.release.draft // false')
          REL_PRE=$(printf '%s' "$ADV" | jq -r '.release.prerelease // false')
          DEP_ENABLE=$(printf '%s' "$ADV" | jq -r '.server.enable // false')
          DEP_HOST=$(printf '%s' "$ADV" | jq -r '.server.host // ""')
          DEP_USER=$(printf '%s' "$ADV" | jq -r '.server.user // "ubuntu"')
          DEP_PORT=$(printf '%s' "$ADV" | jq -r '.server.port // 22')
          DEP_PATH=$(printf '%s' "$ADV" | jq -r '.server.deploy_path // "/opt/mypkg"')
          DEP_SVC=$(printf '%s' "$ADV" | jq -r '.server.service_name // "mypkg"')
          DEP_CMD=$(printf '%s' "$ADV" | jq -r '.server.start_cmd // "python -m mypkg"')
          DEP_SUDO=$(printf '%s' "$ADV" | jq -r '.server.use_sudo // true')
          {
            echo "author_name=$A_NAME"
            echo "author_email=$A_EMAIL"
            echo "license_name=$L_NAME"
            echo "image_name=$IMG_NAME"
            echo "image_tag=$IMG_TAG"
            echo "pkg_mode=$PKG_MODE"
            echo "ghcr_enable=$GHCR_ENABLE"
            echo "ghcr_repo=$GHCR_REPO"
            echo "ghcr_tag=$GHCR_TAG"
            echo "dh_enable=$DH_ENABLE"
            echo "dh_repo=$DH_REPO"
            echo "dh_tag=$DH_TAG"
            echo "rel_enable=$REL_ENABLE"
            echo "rel_tag=$REL_TAG"
            echo "rel_draft=$REL_DRAFT"
            echo "rel_prerelease=$REL_PRE"
            echo "dep_enable=$DEP_ENABLE"
            echo "dep_host=$DEP_HOST"
            echo "dep_user=$DEP_USER"
            echo "dep_port=$DEP_PORT"
            echo "dep_path=$DEP_PATH"
            echo "dep_svc=$DEP_SVC"
            echo "dep_cmd=$DEP_CMD"
            echo "dep_sudo=$DEP_SUDO"
          } | tee -a "$LOG_DIR/parsed_inputs.env"
          for k in author_name author_email license_name image_name image_tag pkg_mode ghcr_enable ghcr_repo ghcr_tag dh_enable dh_repo dh_tag rel_enable rel_tag rel_draft rel_prerelease dep_enable dep_host dep_user dep_port dep_path dep_svc dep_cmd dep_sudo; do
            v=$(grep "^$k=" "$LOG_DIR/parsed_inputs.env" | cut -d= -f2-)
            echo "$k=$v" >> "$GITHUB_OUTPUT"
          done
          printf '%s' "$CP" > copy_plan.json
          printf '%s' "$ADV" > advanced.json
          logf "copy_plan.json & advanced.json saved"

      - name: Validate inputs
        shell: bash
        run: |
          set -Eeuo pipefail
          err(){ echo "❌ $*"; exit 1; }
          [[ "${{ github.event.inputs.package_name }}" =~ ^[a-z0-9_]+$ ]] || err "package_name: 소문자/숫자/_ 만 허용"
          [[ "${{ github.event.inputs.package_version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z\.-]+)?$ ]] || err "package_version: SemVer 필요"
          [[ "${{ github.event.inputs.image_ref }}" =~ ^[a-z0-9._/-]+(:[a-zA-Z0-9._-]+)?$ ]] || err "image_ref 형식 오류"
          if [[ "${{ steps.parse.outputs.rel_enable }}" == "true" ]]; then
            [[ "${{ steps.parse.outputs.rel_tag }}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]] || err "rel_tag: vX.Y.Z 필요"
          fi
          echo "✅ input validation passed"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Pip cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            pip-${{ runner.os }}-

      - name: Wheelhouse cache
        uses: actions/cache@v4
        with:
          path: .pip-wheelhouse
          key: wheelhouse-${{ runner.os }}-main-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            wheelhouse-${{ runner.os }}-main-

      - name: Create Python package skeleton (src layout + server)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          V="${{ github.event.inputs.package_version }}"
          A="${{ steps.parse.outputs.author_name }}"
          E="${{ steps.parse.outputs.author_email }}"
          L="${{ steps.parse.outputs.license_name }}"
          ROOT="workspace/${P}"
          PKG_DIR="$ROOT/src/${P}"
          TEST_DIR="$ROOT/tests"
          DOC_DIR="$ROOT/docs"
          mkdir -p "$PKG_DIR" "$TEST_DIR" "$DOC_DIR"
          cat > "$ROOT/pyproject.toml" <<PYT
          [build-system]
          requires = ["setuptools>=68", "wheel"]
          build-backend = "setuptools.build_meta"
          [project]
          name = "${P}"
          version = "${V}"
          description = "Auto-generated package with EchoOps"
          authors = [{ name="${A}", email="${E}"}]
          license = { text="${L}" }
          readme = "README.md"
          requires-python = ">=3.9"
          classifiers = [
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License"
          ]
          [tool.setuptools.packages.find]
          where = ["src"]
          PYT
          cat > "$ROOT/README.md" <<'MD'
          # Auto Generated Python Package
          - EchoOps generated.
          - Includes Dockerfile, ISO artifacts, SBOM, QA, caches.
          MD
          cat > "$PKG_DIR/__init__.py" <<PY
          __all__ = ["hello"]
          __version__ = "${V}"
          def hello(name: str = "World") -> str:
              return f"Hello, {name}!"
          PY
          # 동적 패키지명 주입 테스트
          cat > "$TEST_DIR/test_hello.py" <<PY
          import importlib, os, sys
          here = os.path.dirname(__file__)
          root = os.path.abspath(os.path.join(here, "..", "src"))
          if root not in sys.path: sys.path.insert(0, root)
          m = importlib.import_module("${P}")
          def test_hello():
              assert m.hello("Echo") == "Hello, Echo!"
          PY
          cat > "$ROOT/Dockerfile" <<'DOCKER'
          FROM python:3.11-slim
          WORKDIR /app
          COPY . /app
          RUN pip install --no-cache-dir .
          ENV PKG="${PKG:-mypkg}"
          CMD ["bash","-lc","python - <<'PY'\nimport os,importlib\nP=os.environ.get('PKG','mypkg')\nm=importlib.import_module(P)\nprint(m.hello('Docker'))\nPY"]
          DOCKER
          mkdir -p "$ROOT/server"
          cat > "$ROOT/server/install_deploy.sh" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          SUDO=${SUDO:-sudo}
          APP_NAME="${APP_NAME:-__APP__}"
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/__APP__}"
          START_CMD="${START_CMD:-python -m __APP__}"
          $SUDO mkdir -p "$DEPLOY_PATH"
          rsync -a ./ "$DEPLOY_PATH/"
          $SUDO python3 -m venv "$DEPLOY_PATH/.venv"
          $SUDO bash -lc "source '$DEPLOY_PATH/.venv/bin/activate' && pip install --upgrade pip && pip install ."
          UNIT="/etc/systemd/system/__APP__.service"
          cat | $SUDO tee "$UNIT" >/dev/null <<EOF
          [Unit]
          Description=__APP__ Service
          After=network.target
          [Service]
          Type=simple
          WorkingDirectory=$DEPLOY_PATH
          ExecStart=$DEPLOY_PATH/.venv/bin/${START_CMD}
          Restart=on-failure
          [Install]
          WantedBy=multi-user.target
          EOF
          $SUDO systemctl daemon-reload
          $SUDO systemctl enable __APP__.service
          $SUDO systemctl restart __APP__.service
          SH
          sed -i "s/__APP__/${P}/g" "$ROOT/server/install_deploy.sh"
          chmod +x "$ROOT/server/install_deploy.sh"
          echo "✅ Python skeleton + server scripts created at $ROOT"

      - name: Install test deps
        shell: bash
        run: |
          set -Eeuo pipefail
          python -m pip install --upgrade pip
          pip install build pytest pytest-cov ruff mypy

      - name: Run unit tests (pytest, coverage, echo-safe import)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          cd "workspace/${P}"
          export PYTHONPATH="$PWD/src${PYTHONPATH:+:$PYTHONPATH}"
          echo "ECHO PYTHONPATH=$PYTHONPATH"
          mkdir -p ../test-results
          pytest -q --junitxml=../test-results/junit.xml --cov="${P}" --cov-report=xml:../test-results/coverage.xml
          echo "✅ tests passed"

      - name: Lint (ruff) + Type check (mypy)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          ruff check "workspace/${P}"
          mypy "workspace/${P}/src" || echo "⚠️ mypy warnings (non-fatal)"

      - name: Build (pip/poetry/conda)
        id: buildpkg
        shell: bash
        run: |
          set -Eeuo pipefail
          MODE="${{ steps.parse.outputs.pkg_mode }}"
          P="${{ github.event.inputs.package_name }}"
          ROOT="workspace/${P}"
          case "$MODE" in
            poetry)
              logf "Packaging mode: poetry"
              python3 -m pip install --upgrade pip poetry build
              (cd "$ROOT" && poetry build)
              ;;
            conda)
              logf "Packaging mode: conda"
              sudo apt-get update -y && sudo apt-get install -y wget bzip2
              MINI="$HOME/miniconda"
              wget -qO ~/miniconda.sh https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
              bash ~/miniconda.sh -b -p "$MINI"
              source "$MINI/etc/profile.d/conda.sh"
              conda create -y -n "${P}" python=3.11
              conda activate "${P}"
              pip install --upgrade pip
              (cd "$ROOT" && pip install .)
              pip install conda-pack
              mkdir -p "$ROOT/dist"
              conda pack -n "${P}" -o "$ROOT/dist/${P}-env.tar.gz"
              logf "Conda env packed at dist/${P}-env.tar.gz"
              ;;
            *)
              logf "Packaging mode: pip (default)"
              python3 -m pip install --upgrade pip build
              python3 -m build "$ROOT"
              ;;
          esac
          ls -al "$ROOT/dist" | tee -a "$LOG_DIR/dist.txt"

      - name: Massive directory generation (+ echo files, except 11)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          COUNT="${{ github.event.inputs.dirs_count }}"
          BASE="workspace/${P}/echo_mass"
          mkdir -p "$BASE"
          cat > "$BASE/perm_apply.sh" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"; mkdir -p "$LOG_DIR"
          OUT="$LOG_DIR/perm-$(date +%Y%m%d%H%M%S).log"
          echo "perm started: $(date)" | tee -a "$OUT"
          for d in "$@"; do
            mkdir -p "$d"; chmod 755 "$d"
            printf 'ECHO %s %s\n' "$(date +%Y-%m-%dT%H:%M:%S)" "$d" | tee -a "$OUT"
            echo "ok" > "$d/.echo.ok"
          done
          echo "done: $(date)" | tee -a "$OUT"
          SH
          chmod +x "$BASE/perm_apply.sh"
          # 11번 제외
          mapfile -t DLIST < <(seq -w 1 "$COUNT" | awk '$1 != "11"{printf "%s\n",$0}' | xargs -I{} echo "$BASE/dir_{}")
          "${BASE}/perm_apply.sh" "${DLIST[@]}"
          echo "✅ Generated $((${#DLIST[@]})) directories with permission echoes (11 excluded)."

      - name: Copy plan dry-run summary
        shell: bash
        run: |
          set -Eeuo pipefail
          if [[ -f copy_plan.json ]]; then
            jq -r '.plans[] | "\(.src) -> \(.dest_rel) | include:[\(.include_globs|join("|"))] exclude:[\(.exclude_globs|join("|"))] max:\(.max_mb)MB"' copy_plan.json || true
          else
            echo "no copy_plan.json"
          fi

      - name: Ensure sources for copy plan (non-fatal provisioning)
        shell: bash
        run: |
          set -Eeuo pipefail
          if ! [[ -d samples ]]; then
            mkdir -p samples
            echo "dummy" > samples/README.txt
            echo "⚠️ created temp samples/"
          fi
          echo "✅ sources ensured"

      - name: Copy directories by copy_plan_json (manifest + checksums)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          ROOT="workspace/${P}"
          PLAN_FILE="copy_plan.json"
          DEST_BASE="$ROOT"
          [[ -f "$PLAN_FILE" ]] || { echo "⚠️ copy_plan.json not found, skipping"; exit 0; }
          mkdir -p "$ROOT/extra_manifests"
          MANIFEST_CSV="$ROOT/extra_manifests/manifest-$(date +%Y%m%d%H%M%S).csv"
          echo "src,resolved_src,dest_rel,relpath,bytes,sha256" > "$MANIFEST_CSV"
          nf(){ if command -v numfmt >/dev/null 2>&1; then numfmt --to=iec "$1"; else echo "$1 bytes"; fi; }
          COUNT_PLANS=$(jq -r '.plans | length' "$PLAN_FILE")
          echo "Copy plans: $COUNT_PLANS"
          for i in $(seq 0 $((COUNT_PLANS-1))); do
            SRC=$(jq -r ".plans[$i].src" "$PLAN_FILE")
            DEST_REL=$(jq -r ".plans[$i].dest_rel // \"extra\"" "$PLAN_FILE")
            MAX_MB=$(jq -r ".plans[$i].max_mb // 100" "$PLAN_FILE")
            INCLUDE_ISO=$(jq -r ".plans[$i].include_in_iso // true" "$PLAN_FILE")
            REQUIRED=$(jq -r ".plans[$i].required // false" "$PLAN_FILE")
            mapfile -t INCLUDES < <(jq -r ".plans[$i].include_globs[]?" "$PLAN_FILE")
            mapfile -t EXCLUDES < <(jq -r ".plans[$i].exclude_globs[]?" "$PLAN_FILE")
            RESOLVED_SRC=""
            if [[ "$SRC" == /* ]]; then
              [[ -d "$SRC" ]] && RESOLVED_SRC="$SRC"
            else
              [[ -d "$GITHUB_WORKSPACE/$SRC" ]] && RESOLVED_SRC="$GITHUB_WORKSPACE/$SRC"
              [[ -z "$RESOLVED_SRC" && -d "$DEST_BASE/$SRC" ]] && RESOLVED_SRC="$DEST_BASE/$SRC"
              [[ -z "$RESOLVED_SRC" && -d "$SRC" ]] && RESOLVED_SRC="$SRC"
            fi
            if [[ -z "$RESOLVED_SRC" ]]; then
              if [[ "$REQUIRED" == "true" ]]; then
                echo "❌ Plan[$i] required=true but src not found: $SRC"; exit 1
              else
                echo "⚠️ Plan[$i] SRC not found: $SRC — skipping"
                continue
              fi
            fi
            DEST_DIR="$DEST_BASE/$DEST_REL"; mkdir -p "$DEST_DIR"
            RSYNC_ARGS=(-a --delete --prune-empty-dirs)
            for p in "${INCLUDES[@]}";  do RSYNC_ARGS+=(--include "$p"); done
            for p in "${EXCLUDES[@]}";  do RSYNC_ARGS+=(--exclude "$p"); done
            RSYNC_ARGS+=(--exclude '.git/' --exclude '.github/')
            RSYNC_ARGS+=(--include '*/' --exclude '*')
            TMP_STAGE="$(mktemp -d)"
            rsync "${RSYNC_ARGS[@]}" "$RESOLVED_SRC/" "$TMP_STAGE/"
            TOTAL_BYTES=$(du -sb "$TMP_STAGE" | awk '{print $1}')
            LIMIT_BYTES=$((MAX_MB * 1024 * 1024))
            if (( TOTAL_BYTES > LIMIT_BYTES )); then
              echo "⚠️ Plan[$i] size exceed: $(nf "$TOTAL_BYTES") > $(nf "$LIMIT_BYTES")"
              mkdir -p "$DEST_DIR"; REMAIN=$LIMIT_BYTES
              mapfile -t FILES < <(find "$TMP_STAGE" -type f -printf '%T@ %p\n' | sort -nr | awk '{sub($1 FS,""); print}')
              for f in "${FILES[@]}"; do
                sz=$(stat -c%s "$f"); (( sz <= REMAIN )) || continue
                rel="${f#"$TMP_STAGE/"}"
                mkdir -p "$DEST_DIR/$(dirname "$rel")"
                cp -a "$f" "$DEST_DIR/$rel"
                REMAIN=$((REMAIN - sz))
              done
            else
              rsync -a --delete "$TMP_STAGE/" "$DEST_DIR/"
            fi
            if [[ -d "$DEST_DIR" ]]; then
              while IFS= read -r -d '' f; do
                rel="${f#"$DEST_BASE/"}"
                bytes=$(stat -c%s "$f")
                sha=$(sha256sum "$f" | awk '{print $1}')
                printf '%s,%s,%s,%s,%s\n' "$SRC" "$RESOLVED_SRC" "$DEST_REL" "${rel#"$DEST_REL/"}" "$bytes" "$sha" >> "$MANIFEST_CSV"
              done < <(find "$DEST_DIR" -type f -print0)
            fi
            rm -rf "$TMP_STAGE"
            echo "include_in_iso=$([[ "$INCLUDE_ISO" == "true" ]] && echo true || echo false)" > "$DEST_DIR/.iso.include"
            echo "Plan[$i] done → $DEST_DIR"
          done
          echo "✅ Manifest generated: $MANIFEST_CSV"

      - name: Optional Docker build + save (single-arch local)
        if: ${{ github.event.inputs.build_docker == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          ROOT="workspace/${P}"
          IMG_INPUT='${{ github.event.inputs.image_ref }}'
          if [[ "$IMG_INPUT" == *:* ]]; then IMG_NAME="${IMG_INPUT%%:*}"; IMG_TAG="${IMG_INPUT##*:}"; else IMG_NAME="$IMG_INPUT"; IMG_TAG="latest"; fi
          IMG="${IMG_NAME}:${IMG_TAG}"
          echo "Building Docker image: $IMG"
          docker build -t "$IMG" "$ROOT"
          mkdir -p artifacts
          docker save "$IMG" | gzip -c > "artifacts/${IMG_NAME##*/}-${IMG_TAG}.tar.gz"
          echo "✅ image built & saved"

      - name: Install Syft & Trivy
        shell: bash
        run: |
          set -Eeuo pipefail
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOMs (pkg & image)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p security
          syft scan dir:workspace/${{ github.event.inputs.package_name }} -o spdx-json > security/pkg-sbom.spdx.json || syft packages dir:workspace/${{ github.event.inputs.package_name }} -o spdx-json > security/pkg-sbom.spdx.json
          IMG_INPUT='${{ github.event.inputs.image_ref }}'
          if [[ "${{ github.event.inputs.build_docker }}" == "true" ]]; then
            if [[ "$IMG_INPUT" == *:* ]]; then IMG_NAME="${IMG_INPUT%%:*}"; IMG_TAG="${IMG_INPUT##*:}"; else IMG_NAME="$IMG_INPUT"; IMG_TAG="latest"; fi
            syft "${IMG_NAME}:${IMG_TAG}" -o spdx-json > security/image-sbom.spdx.json || true
          fi

      - name: Vulnerability scan (Trivy; fail on HIGH+)
        if: ${{ github.event.inputs.build_docker == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          IMG_INPUT='${{ github.event.inputs.image_ref }}'
          if [[ "$IMG_INPUT" == *:* ]]; then IMG_NAME="${IMG_INPUT%%:*}"; IMG_TAG="${IMG_INPUT##*:}"; else IMG_NAME="$IMG_INPUT"; IMG_TAG="latest"; fi
          trivy image --no-progress --severity HIGH,CRITICAL --exit-code 1 "${IMG_NAME}:${IMG_TAG}" || { echo "⚠️ HIGH/CRITICAL found"; exit 1; }

      - name: Prepare ISO staging & info injection
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          ROOT="workspace/${P}"
          STAGE="iso_stage/${P}"
          mkdir -p "$STAGE/config" "$STAGE/pkg" "$STAGE/docs" "$STAGE/extra" "$STAGE/server"
          echo "${{ github.repository }},${{ github.run_id }},${{ github.ref_name }}" > "$STAGE/build_info.csv"
          printf '%s' '${{ github.event.inputs.inject_info_json }}' | jq . > "$STAGE/config/inject.json"
          cp -a "$ROOT/dist" "$STAGE/pkg/" || true
          cp -a .github/echo_logs "$STAGE/docs/" || true
          cp -a "$ROOT/echo_mass/perm_apply.sh" "$STAGE/docs/" || echo "⚠️ no perm_apply.sh"
          [[ -d "$ROOT/extra_manifests" ]] && cp -a "$ROOT/extra_manifests" "$STAGE/docs/" || true
          cp -a "$ROOT/server" "$STAGE/" || true
          if [[ -d "$ROOT" ]]; then
            while IFS= read -r -d '' marker; do
              d="$(dirname "$marker")"; rel="${d#"$ROOT/"}"
              mkdir -p "$STAGE/extra/$rel"
              rsync -a "$d/" "$STAGE/extra/$rel/"
            done < <(find "$ROOT" -type f -name ".iso.include" -print0 | xargs -0 grep -l "include_in_iso=true" || true)
          fi
          cat > "$STAGE/README.txt" <<'TXT'
          Echo ISO — includes:
          - pkg/dist
          - config/inject.json
          - docs/echo_logs, extra_manifests, perm_apply.sh
          - extra/* (copy-plan selected)
          - server/*
          TXT
          echo "ISO staging prepared at $STAGE"

      - name: Add ISO integrity bundle (SHA256 + SBOM copy)
        shell: bash
        run: |
          set -Eeuo pipefail
          STAGE="iso_stage/${{ github.event.inputs.package_name }}"
          mkdir -p "$STAGE/docs"
          (cd "$STAGE" && find . -type f -print0 | xargs -0 sha256sum) > "$STAGE/docs/ISO_FILES.sha256"
          cp -a security/*.json "$STAGE/docs/" 2>/dev/null || true

      - name: Build ISO
        shell: bash
        run: |
          set -Eeuo pipefail
          ISO_NAME="${{ github.event.inputs.package_name }}-${{ github.event.inputs.package_version }}.iso"
          LABEL="${{ github.event.inputs.iso_label }}"
          STAGE="iso_stage/${{ github.event.inputs.package_name }}"
          mkdir -p artifacts
          if command -v xorriso >/dev/null 2>&1; then
            xorriso -as mkisofs -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          else
            genisoimage -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          fi
          (cd artifacts && sha256sum "${ISO_NAME}" > "${ISO_NAME}.sha256" )
          echo "✅ ISO built"

      - name: Set up QEMU
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx (docker-container driver)
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Buildx cache
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ github.ref }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ github.ref }}-
            buildx-

      - name: Compute GHCR semver tags
        id: ghcrtags
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          REPO="${{ steps.parse.outputs.ghcr_repo }}"
          V="${{ github.event.inputs.package_version }}"
          RUN="${{ github.run_id }}"
          MAJOR="${V%%.*}"
          MINOR="${V%.*}"
          TAGS="${REPO}:${V}-${RUN},${REPO}:${MAJOR}.${MINOR#${MAJOR}.}-${RUN},${REPO}:${MAJOR}-${RUN},${REPO}:latest"
          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"
          echo "Computed tags: ${TAGS}"

      - name: Login to GHCR
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build multi-arch and push (GHCR)
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: workspace/${{ github.event.inputs.package_name }}
          file: workspace/${{ github.event.inputs.package_name }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.ghcrtags.outputs.tags }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      - name: Cosign keyless sign (GH OIDC)
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.ghcr_enable == 'true' }}
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -Eeuo pipefail
          curl -sSfL https://raw.githubusercontent.com/sigstore/cosign/main/install.sh | sh -s -- -b /usr/local/bin
          IFS=',' read -r -a TAGS <<< "${{ steps.ghcrtags.outputs.tags }}"
          for t in "${TAGS[@]}"; do
            echo "Signing (keyless) $t"
            cosign sign "$t"
          done
          if [[ -f security/image-sbom.spdx.json ]]; then
            cosign attest --predicate security/image-sbom.spdx.json --type spdx "${TAGS[0]}"
          fi
          echo "✅ cosign keyless done"

      - name: Sign ISO checksum (optional key-based)
        env:
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        if: ${{ env.COSIGN_KEY != '' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          curl -sSfL https://raw.githubusercontent.com/sigstore/cosign/main/install.sh | sh -s -- -b /usr/local/bin
          (cd artifacts && sha256sum *.iso > ISO_SUMS.sha256)
          cosign sign-blob --key env://COSIGN_KEY artifacts/ISO_SUMS.sha256 > artifacts/ISO_SUMS.sig
          echo "✅ ISO checksum signed"

      - name: Push image to Docker Hub (optional)
        if: ${{ github.event.inputs.build_docker == 'true' && steps.parse.outputs.dh_enable == 'true' }}
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          SRC_IMG_INPUT='${{ github.event.inputs.image_ref }}'
          if [[ "$SRC_IMG_INPUT" == *:* ]]; then SRC_IMG_NAME="${SRC_IMG_INPUT%%:*}"; SRC_IMG_TAG="${SRC_IMG_INPUT##*:}"; else SRC_IMG_NAME="$SRC_IMG_INPUT"; SRC_IMG_TAG="latest"; fi
          DEST_REPO="${{ steps.parse.outputs.dh_repo }}"
          DEST_TAG="${{ steps.parse.outputs.dh_tag || steps.parse.outputs.image_tag }}"
          if [[ -z "$DOCKERHUB_USERNAME" || -z "$DOCKERHUB_TOKEN" || -z "$DEST_REPO" ]]; then
            echo "⚠️ DockerHub creds/repo missing; exporting tar fallback"
            mkdir -p artifacts
            docker save "${SRC_IMG_NAME}:${SRC_IMG_TAG}" | gzip -c > "artifacts/${SRC_IMG_NAME##*/}-${SRC_IMG_TAG}.tar.gz"
            exit 0
          fi
          echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
          docker tag "${SRC_IMG_NAME}:${SRC_IMG_TAG}" "$DEST_REPO:$DEST_TAG"
          docker push "$DEST_REPO:$DEST_TAG"
          echo "✅ pushed to Docker Hub: $DEST_REPO:$DEST_TAG"

      - name: Secret scan (gitleaks)
        uses: gitleaks/gitleaks-action@v2
        with:
          args: detect --no-git -v

      - name: License check (pip-licenses)
        shell: bash
        run: |
          set -Eeuo pipefail
          pip install pip-licenses
          mkdir -p security
          pip-licenses --format=json --with-authors --with-urls > security/pip-licenses.json
          echo "✅ pip-licenses generated"

      - name: Ensure release drafter config
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p .github
          cat > .github/release-drafter.yml <<'YML'
          name-template: 'v$NEXT_PATCH_VERSION'
          tag-template: 'v$NEXT_PATCH_VERSION'
          categories:
            - title: 🚀 Features
              labels: [feature, feat]
            - title: 🐛 Fixes
              labels: [fix, bug]
          change-template: '- $TITLE (#$NUMBER) @$AUTHOR'
          YML
          echo "✅ release-drafter.yml ready"

      - name: Draft release notes
        uses: release-drafter/release-drafter@v6
        with:
          config-name: release-drafter.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate changelog (for release)
        if: ${{ steps.parse.outputs.rel_enable == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p artifacts
          git fetch --tags --force || true
          PREV_TAG=$(git tag --sort=-creatordate | sed -n '2p')
          CURR_TAG="${{ steps.parse.outputs.rel_tag }}"
          git log --pretty=format:"* %h %s (%an)" ${PREV_TAG}..HEAD > artifacts/CHANGELOG.txt || true
          [[ -s artifacts/CHANGELOG.txt ]] || echo "* Initial release" > artifacts/CHANGELOG.txt

      - name: Create GitHub Release
        if: ${{ steps.parse.outputs.rel_enable == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.parse.outputs.rel_tag }}
          draft: ${{ steps.parse.outputs.rel_draft }}
          prerelease: ${{ steps.parse.outputs.rel_prerelease }}
          files: |
            artifacts/*.iso
            artifacts/*.sha256
            artifacts/CHANGELOG.txt
            artifacts/*.tar.gz
            security/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to server via SSH (optional)
        if: ${{ steps.parse.outputs.dep_enable == 'true' }}
        shell: bash
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_KEY }}
        run: |
          set -Eeuo pipefail
          P="${{ github.event.inputs.package_name }}"
          ROOT="workspace/${P}"
          HOST="${{ steps.parse.outputs.dep_host }}"
          USER="${{ steps.parse.outputs.dep_user }}"
          PORT="${{ steps.parse.outputs.dep_port }}"
          DEST="${{ steps.parse.outputs.dep_path }}"
          SVC="${{ steps.parse.outputs.dep_svc }}"
          CMD="${{ steps.parse.outputs.dep_cmd }}"
          USE_SUDO="${{ steps.parse.outputs.dep_sudo }}"
          [[ -z "$SSH_PRIVATE_KEY" ]] && { echo "⚠️ SERVER_SSH_KEY secret missing"; exit 0; }
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh -o StrictHostKeyChecking=no -p "$PORT" "$USER@$HOST" "mkdir -p $DEST"
          rsync -az -e "ssh -p $PORT -o StrictHostKeyChecking=no" "$ROOT/" "$USER@$HOST:$DEST/"
          SUDO_FLAG=""; [[ "$USE_SUDO" == "true" ]] && SUDO_FLAG="SUDO=sudo"
          ssh -o StrictHostKeyChecking=no -p "$PORT" "$USER@$HOST" \
            "cd $DEST && $SUDO_FLAG APP_NAME=${P} DEPLOY_PATH=$DEST START_CMD='$CMD' bash ./server/install_deploy.sh"
          echo "✅ deployed to $USER@$HOST:$DEST"

      - name: Post-deploy health check & rollback
        if: ${{ steps.parse.outputs.dep_enable == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          HOST="${{ steps.parse.outputs.dep_host }}"
          USER="${{ steps.parse.outputs.dep_user }}"
          PORT="${{ steps.parse.outputs.dep_port }}"
          SVC="${{ steps.parse.outputs.dep_svc }}"
          ssh -o StrictHostKeyChecking=no -p "$PORT" "$USER@$HOST" \
            "systemctl is-active $SVC || (echo '❌ unhealthy, try restart'; sudo systemctl restart $SVC; sleep 2; systemctl is-active $SVC || (echo '❌ still unhealthy'; exit 1))"
          echo "✅ service healthy"

      - name: Retry wrapper example (noop)
        shell: bash
        run: |
          set -Eeuo pipefail
          n=0; until [ $n -ge 3 ]; do
            echo "✅ try $((n+1))/3"; sleep 1 && break
            n=$((n+1)); echo "retry $n/3"; sleep 5
          done

      - name: Write dependabot.yml
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p .github
          cat > .github/dependabot.yml <<'YML'
          version: 2
          updates:
            - package-ecosystem: pip
              directory: "/"
              schedule: { interval: weekly }
            - package-ecosystem: github-actions
              directory: "/"
              schedule: { interval: weekly }
          YML
          echo "✅ dependabot.yml ready"

      - name: Upload artifacts (all-in-one, retention 7d)
        uses: actions/upload-artifact@v4
        with:
          name: echo-image-iso-${{ github.run_id }}
          path: |
            artifacts/**
            workspace/**/dist/**
            .github/echo_logs/**
            security/**
            iso_stage/**
            workspace/**/test-results/**
          retention-days: 7
          if-no-files-found: warn

      - name: Cleanup docker/apt cache
        if: ${{ always() }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker system prune -af || true
          sudo rm -rf /var/lib/apt/lists/* || true
          echo "✅ cleanup done"
