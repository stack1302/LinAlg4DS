name: "üêç PyPkg + Echo/CopyPlan + Docker Image + ISO + Push + Release + Deploy"

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "ÌååÏù¥Ïç¨ Ìå®ÌÇ§ÏßÄ Ïù¥Î¶Ñ (PEP 8 ÏÜåÎ¨∏Ïûê, ÌïòÏù¥Ìîà/Ï†ê Í∏àÏßÄ)"
        required: true
        default: "mypkg"
      package_version:
        description: "Ìå®ÌÇ§ÏßÄ Î≤ÑÏ†Ñ"
        required: true
        default: "0.1.0"
      dirs_count:
        description: "ÎåÄÎüâ ÏÉùÏÑ± ÎîîÎ†âÌÜ†Î¶¨ Í∞úÏàò (Ïòà: 2000)"
        required: true
        default: "500"
      iso_label:
        description: "ISO Î≥ºÎ•® ÎùºÎ≤®(ÏòÅÎ¨∏/Ïà´Ïûê/Ïñ∏ÎçîÏä§ÏΩîÏñ¥)"
        required: true
        default: "ECHO_ISO"
      inject_info_json:
        description: "ISO Ï£ºÏûÖ JSON (Ïòà: {\"env\":\"prod\",\"team\":\"devops\"})"
        required: false
        default: "{\"env\":\"dev\",\"team\":\"finops\"}"
      metadata_json:
        description: "Ìå®ÌÇ§ÏßÄ Î©îÌÉÄ(JSON): {\"author_name\":\"...\",\"author_email\":\"...\",\"license_name\":\"MIT\"}"
        required: false
        default: "{\"author_name\":\"Your Name\",\"author_email\":\"you@example.com\",\"license_name\":\"MIT\"}"
      image_ref:
        description: "Docker Ïù¥ÎØ∏ÏßÄ Ï∞∏Ï°∞(Ïù¥Î¶Ñ:ÌÉúÍ∑∏), Ïòà: mypkg-app:latest"
        required: true
        default: "mypkg-app:latest"
      build_docker:
        description: "Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú/Ï†ÄÏû• ÏàòÌñâ"
        required: true
        type: boolean
        default: true
      copy_plan_json:
        description: >-
          ÎîîÎ†âÌÜ†Î¶¨ Î≥µÏÇ¨ Í≥ÑÌöç(JSON). ÌïÑÎìú: src, dest_rel, include_globs[], exclude_globs[], max_mb, include_in_iso, required
        required: false
        default: "{\"plans\":[{\"src\":\"samples\",\"dest_rel\":\"extra/samples\",\"include_globs\":[\"**/*\"],\"exclude_globs\":[\"**/.git/**\",\"**/.github/**\"],\"max_mb\":100,\"include_in_iso\":true,\"required\":false}]}"
      advanced_json:
        description: >-
          ÌôïÏû• ÏÑ§Ï†ï(JSON). Ïòà: {
            "packaging":{"mode":"pip"}, 
            "ghcr":{"enable":true,"repo":"ghcr.io/<OWNER>/<NAME>","tag":"latest"},
            "dockerhub":{"enable":false,"repo":"<user>/<name>","tag":"latest"},
            "release":{"enable":true,"tag":"v0.1.0","draft":false,"prerelease":false},
            "server":{"enable":false,"host":"example.com","user":"ubuntu","port":22,"deploy_path":"/opt/mypkg","service_name":"mypkg","start_cmd":"python -m mypkg","use_sudo":true}
          }
        required: false
        default: "{\"packaging\":{\"mode\":\"pip\"},\"ghcr\":{\"enable\":false},\"dockerhub\":{\"enable\":false},\"release\":{\"enable\":false},\"server\":{\"enable\":false}}"

permissions:
  contents: write        # ReleaseÏóê ÌïÑÏöî
  packages: write        # GHCR Ìë∏ÏãúÏóê ÌïÑÏöî
  actions: read

env:
  TZ: Asia/Seoul
  LOG_DIR: .github/echo_logs
  ECHO_OK: "‚úÖ"
  ECHO_WARN: "‚ö†Ô∏è"
  ECHO_FAIL: "‚ùå"
  DOCKER_BUILDKIT: "1"

jobs:
  all-in-one:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Î™®Îì† bash Ïä§ÌÖùÏóêÏÑú ÏóêÏΩî Ìó¨Ìçº ÏÇ¨Ïö© (ÌòÑÏû¨/Îã§Ïùå Ïä§ÌÖù Î™®Îëê)
      - name: Global echo helpers (persist across steps)
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > "$GITHUB_WORKSPACE/.bashenv" <<'SH'
          ECHO_OK="${ECHO_OK:-‚úÖ}"
          ECHO_WARN="${ECHO_WARN:-‚ö†Ô∏è}"
          ECHO_FAIL="${ECHO_FAIL:-‚ùå}"
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"
          mkdir -p "$LOG_DIR"
          SAFE_LOG="${SAFE_LOG:-${LOG_DIR}/run-$(date +%Y%m%d%H%M%S).log}"
          echoe(){ printf '%s %s\n' "${ECHO_OK}" "$*"; }
          warn(){  printf '%s %s\n' "${ECHO_WARN}" "$*"; }
          fail(){  printf '%s %s\n' "${ECHO_FAIL}" "$*"; }
          logf(){  printf '%s\n' "$*" | tee -a "$SAFE_LOG"; }
          SH
          export BASH_ENV="$GITHUB_WORKSPACE/.bashenv"
          echo "BASH_ENV=$BASH_ENV" >> "$GITHUB_ENV"
          bash -lc 'echoe "helpers loaded"; logf "helpers ready"'

      - name: Install toolchain (Python, ISO, copy, deploy)
        shell: bash
        run: |
          set -Eeuo pipefail
          logf "Installing build/copy/deploy tools"
          sudo apt-get update -y
          sudo apt-get install -y python3 python3-venv python3-pip python3-setuptools python3-wheel \
              git jq rsync xorriso genisoimage dosfstools openssh-client
          python3 --version | tee -a "$LOG_DIR/python.txt"
          pip3 --version | tee -a "$LOG_DIR/pip.txt"
          rsync --version | head -n1 | tee -a "$LOG_DIR/rsync.txt"
          logf "Installed: xorriso/genisoimage/jq/rsync/ssh"

      - name: Parse inputs (metadata_json, image_ref, copy_plan_json, advanced_json)
        id: parse
        shell: bash
        run: |
          set -Eeuo pipefail
          MJ='${{ inputs.metadata_json }}'
          A_NAME=$(printf '%s' "$MJ" | jq -r '.author_name // "Your Name"')
          A_EMAIL=$(printf '%s' "$MJ" | jq -r '.author_email // "you@example.com"')
          L_NAME=$(printf '%s' "$MJ" | jq -r '.license_name // "MIT"')

          IMG='${{ inputs.image_ref }}'
          if [[ "$IMG" == *:* ]]; then IMG_NAME="${IMG%%:*}"; IMG_TAG="${IMG##*:}"; else IMG_NAME="$IMG"; IMG_TAG="latest"; fi

          CP='${{ inputs.copy_plan_json }}'
          printf '%s' "$CP" | jq . >/dev/null

          ADV='${{ inputs.advanced_json }}'
          printf '%s' "$ADV" | jq . >/dev/null

          PKG_MODE=$(printf '%s' "$ADV" | jq -r '.packaging.mode // "pip"') # pip|poetry|conda

          GHCR_ENABLE=$(printf '%s' "$ADV" | jq -r '.ghcr.enable // false')
          GHCR_REPO=$(printf '%s' "$ADV" | jq -r '.ghcr.repo // ""')
          GHCR_TAG=$(printf '%s' "$ADV" | jq -r '.ghcr.tag // ""')

          DH_ENABLE=$(printf '%s' "$ADV" | jq -r '.dockerhub.enable // false')
          DH_REPO=$(printf '%s' "$ADV" | jq -r '.dockerhub.repo // ""')
          DH_TAG=$(printf '%s' "$ADV" | jq -r '.dockerhub.tag // ""')

          REL_ENABLE=$(printf '%s' "$ADV" | jq -r '.release.enable // false')
          REL_TAG=$(printf '%s' "$ADV" | jq -r '.release.tag // ""')
          REL_DRAFT=$(printf '%s' "$ADV" | jq -r '.release.draft // false')
          REL_PRE=$(printf '%s' "$ADV" | jq -r '.release.prerelease // false')

          DEP_ENABLE=$(printf '%s' "$ADV" | jq -r '.server.enable // false')
          DEP_HOST=$(printf '%s' "$ADV" | jq -r '.server.host // ""')
          DEP_USER=$(printf '%s' "$ADV" | jq -r '.server.user // "ubuntu"')
          DEP_PORT=$(printf '%s' "$ADV" | jq -r '.server.port // 22')
          DEP_PATH=$(printf '%s' "$ADV" | jq -r '.server.deploy_path // "/opt/mypkg"')
          DEP_SVC=$(printf '%s' "$ADV" | jq -r '.server.service_name // "mypkg"')
          DEP_CMD=$(printf '%s' "$ADV" | jq -r '.server.start_cmd // "python -m mypkg"')
          DEP_SUDO=$(printf '%s' "$ADV" | jq -r '.server.use_sudo // true')

          {
            echo "author_name=$A_NAME"
            echo "author_email=$A_EMAIL"
            echo "license_name=$L_NAME"
            echo "image_name=$IMG_NAME"
            echo "image_tag=$IMG_TAG"
            echo "pkg_mode=$PKG_MODE"
            echo "ghcr_enable=$GHCR_ENABLE"
            echo "ghcr_repo=$GHCR_REPO"
            echo "ghcr_tag=$GHCR_TAG"
            echo "dh_enable=$DH_ENABLE"
            echo "dh_repo=$DH_REPO"
            echo "dh_tag=$DH_TAG"
            echo "rel_enable=$REL_ENABLE"
            echo "rel_tag=$REL_TAG"
            echo "rel_draft=$REL_DRAFT"
            echo "rel_prerelease=$REL_PRE"
            echo "dep_enable=$DEP_ENABLE"
            echo "dep_host=$DEP_HOST"
            echo "dep_user=$DEP_USER"
            echo "dep_port=$DEP_PORT"
            echo "dep_path=$DEP_PATH"
            echo "dep_svc=$DEP_SVC"
            echo "dep_cmd=$DEP_CMD"
            echo "dep_sudo=$DEP_SUDO"
          } | tee -a "$LOG_DIR/parsed_inputs.env"

          for k in author_name author_email license_name image_name image_tag pkg_mode ghcr_enable ghcr_repo ghcr_tag dh_enable dh_repo dh_tag rel_enable rel_tag rel_draft rel_prerelease dep_enable dep_host dep_user dep_port dep_path dep_svc dep_cmd dep_sudo; do
            v=$(grep "^$k=" "$LOG_DIR/parsed_inputs.env" | cut -d= -f2-)
            echo "$k=$v" >> "$GITHUB_OUTPUT"
          done

          printf '%s' "$CP" > copy_plan.json
          printf '%s' "$ADV" > advanced.json
          logf "copy_plan.json & advanced.json saved"

      - name: Create Python package skeleton (PEP 621 / pyproject.toml + server scripts)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          V="${{ inputs.package_version }}"
          A="${{ steps.parse.outputs.author_name }}"
          E="${{ steps.parse.outputs.author_email }}"
          L="${{ steps.parse.outputs.license_name }}"
          ROOT="workspace/${P}"
          PKG_DIR="$ROOT/src/${P}"
          TEST_DIR="$ROOT/tests"
          DOC_DIR="$ROOT/docs"
          mkdir -p "$PKG_DIR" "$TEST_DIR" "$DOC_DIR"

          # pyproject (setuptools)
          cat > "$ROOT/pyproject.toml" <<'PYT'
          [build-system]
          requires = ["setuptools>=68", "wheel"]
          build-backend = "setuptools.build_meta"
          [project]
          name = "__PKG_NAME__"
          version = "__PKG_VER__"
          description = "Auto-generated package with EchoOps"
          authors = [{ name="__AUTHOR__", email="__EMAIL__"}]
          license = { text="__LICENSE__" }
          readme = "README.md"
          requires-python = ">=3.9"
          classifiers = [
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License"
          ]
          [project.urls]
          Homepage = "https://example.com"
          [tool.setuptools.packages.find]
          where = ["src"]
          PYT
          sed -i "s/__PKG_NAME__/${P}/g" "$ROOT/pyproject.toml"
          sed -i "s/__PKG_VER__/${V}/g" "$ROOT/pyproject.toml"
          sed -i "s/__AUTHOR__/${A}/g" "$ROOT/pyproject.toml"
          sed -i "s/__EMAIL__/${E}/g" "$ROOT/pyproject.toml"
          sed -i "s/__LICENSE__/${L}/g" "$ROOT/pyproject.toml"

          # README
          cat > "$ROOT/README.md" <<'MD'
          # Auto Generated Python Package
          - EchoOps generated.
          - Includes Dockerfile, ISO injection artifacts, copy-plan manifest, and server deploy scripts.
          MD

          # package
          cat > "$PKG_DIR/__init__.py" <<'PY'
          __all__ = ["hello"]
          __version__ = "__VER__"
          def hello(name: str = "World") -> str:
              return f"Hello, {name}!"
          PY
          sed -i "s/__VER__/${V}/g" "$PKG_DIR/__init__.py"

          cat > "$TEST_DIR/test_hello.py" <<'PY'
          from __future__ import annotations
          from __pkg__.__init__ import hello
          def test_hello():
              assert hello("Echo") == "Hello, Echo!"
          PY
          sed -i "s/__pkg__/${P}/g" "$TEST_DIR/test_hello.py"

          # Dockerfile
          cat > "$ROOT/Dockerfile" <<'DOCKER'
          FROM python:3.11-slim
          WORKDIR /app
          COPY . /app
          RUN pip install --no-cache-dir .
          CMD ["python","-c","import __PKG__; print(__PKG__.hello('Docker'))"]
          DOCKER
          sed -i "s/__PKG__/${P}/g" "$ROOT/Dockerfile"

          # --- Server deploy artifacts (install script + systemd unit) ---
          mkdir -p "$ROOT/server"
          cat > "$ROOT/server/install_deploy.sh" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          SUDO=${SUDO:-sudo}
          APP_NAME="${APP_NAME:-__APP__}"
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/__APP__}"
          START_CMD="${START_CMD:-python -m __APP__}"
          echo "[install] creating $DEPLOY_PATH"
          $SUDO mkdir -p "$DEPLOY_PATH"
          $SUDO rsync -a ./ "$DEPLOY_PATH/"
          echo "[install] creating venv"
          $SUDO python3 -m venv "$DEPLOY_PATH/.venv"
          $SUDO bash -lc "source \"$DEPLOY_PATH/.venv/bin/activate\" && pip install --upgrade pip && pip install ."
          UNIT="/etc/systemd/system/__APP__.service"
          echo "[install] writing systemd unit to $UNIT"
          cat | $SUDO tee "$UNIT" >/dev/null <<EOF
          [Unit]
          Description=__APP__ Service
          After=network.target
          [Service]
          Type=simple
          WorkingDirectory=$DEPLOY_PATH
          ExecStart=$DEPLOY_PATH/.venv/bin/${START_CMD}
          Restart=on-failure
          [Install]
          WantedBy=multi-user.target
          EOF
          $SUDO systemctl daemon-reload
          $SUDO systemctl enable __APP__.service
          $SUDO systemctl restart __APP__.service
          echo "[install] done."
          SH
          sed -i "s/__APP__/${P}/g" "$ROOT/server/install_deploy.sh"
          chmod +x "$ROOT/server/install_deploy.sh"

          logf "Python skeleton + server scripts created at $ROOT"

      # Packaging Î™®ÎìúÏóê Îî∞Îùº ÎπåÎìú
      - name: Build (pip/poetry/conda)
        id: buildpkg
        shell: bash
        run: |
          set -Eeuo pipefail
          MODE="${{ steps.parse.outputs.pkg_mode }}"
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"

          case "$MODE" in
            poetry)
              logf "Packaging mode: poetry"
              python3 -m pip install --upgrade pip poetry build
              # poetryÍ∞Ä Í∏∞Ï°¥ pyprojectÎ°úÎèÑ ÎèôÏûë(PEP517) ‚Üí poetry build
              (cd "$ROOT" && poetry build)
              ;;
            conda)
              logf "Packaging mode: conda (env pack)"
              # Miniconda ÏÑ§Ïπò ÌõÑ conda-pack Í∏∞Î∞òÏúºÎ°ú Ïã§Ìñâ ÌôòÍ≤Ω ÏïÑÏπ¥Ïù¥Î∏å
              sudo apt-get update -y && sudo apt-get install -y wget bzip2
              MINI="$HOME/miniconda"
              wget -qO ~/miniconda.sh https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
              bash ~/miniconda.sh -b -p "$MINI"
              source "$MINI/etc/profile.d/conda.sh"
              conda create -y -n "${P}" python=3.11
              conda activate "${P}"
              pip install --upgrade pip
              (cd "$ROOT" && pip install .)
              pip install conda-pack
              mkdir -p "$ROOT/dist"
              conda pack -n "${P}" -o "$ROOT/dist/${P}-env.tar.gz"
              logf "Conda env packed at dist/${P}-env.tar.gz"
              ;;
            *)
              logf "Packaging mode: pip (default)"
              python3 -m pip install --upgrade pip build
              python3 -m build "$ROOT"
              ;;
          esac

          ls -al "$ROOT/dist" | tee -a "$LOG_DIR/dist.txt"

      - name: Massive directory generation (+ echo-style permission files)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          COUNT="${{ inputs.dirs_count }}"
          BASE="workspace/${P}/echo_mass"
          mkdir -p "$BASE"

          cat > "$BASE/perm_apply.sh" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"
          mkdir -p "$LOG_DIR"
          OUT="$LOG_DIR/perm-$(date +%Y%m%d%H%M%S).log"
          echo "perm started: $(date)" | tee -a "$OUT"
          for d in "$@"; do
            mkdir -p "$d"
            chmod 755 "$d"
            printf 'ECHO %s %s\n' "$(date +%Y-%m-%dT%H:%M:%S)" "$d" | tee -a "$OUT"
            echo "ok" > "$d/.echo.ok"
          done
          echo "done: $(date)" | tee -a "$OUT"
          SH
          chmod +x "$BASE/perm_apply.sh"

          mapfile -t DLIST < <(seq -w 1 "$COUNT" | xargs -I{} echo "$BASE/dir_{}")
          "${BASE}/perm_apply.sh" "${DLIST[@]}"
          logf "Generated $COUNT directories with permission echoes."

      # === ÎîîÎ†âÌÜ†Î¶¨ Î≥µÏÇ¨(Í≤ΩÎ°ú Ìï¥ÏÑù + required + Ïö©Îüâ Ï†úÌïú + Îß§ÎãàÌéòÏä§Ìä∏/Ï≤¥ÌÅ¨ÏÑ¨ + ISO Ìè¨Ìï® ÎßàÏª§) ===
      - name: Copy directories by copy_plan_json (echo + manifest + checksums)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          PLAN_FILE="copy_plan.json"
          DEST_BASE="$ROOT"

          [[ -f "$PLAN_FILE" ]] || { warn "copy_plan.json not found, skipping"; exit 0; }

          mkdir -p "$ROOT/extra_manifests"
          MANIFEST_CSV="$ROOT/extra_manifests/manifest-$(date +%Y%m%d%H%M%S).csv"
          echo "src,resolved_src,dest_rel,relpath,bytes,sha256" > "$MANIFEST_CSV"

          nf(){ if command -v numfmt >/dev/null 2>&1; then numfmt --to=iec "$1"; else echo "$1 bytes"; fi; }

          COUNT_PLANS=$(jq -r '.plans | length' "$PLAN_FILE")
          logf "Copy plans: $COUNT_PLANS"

          for i in $(seq 0 $((COUNT_PLANS-1))); do
            SRC=$(jq -r ".plans[$i].src" "$PLAN_FILE")
            DEST_REL=$(jq -r ".plans[$i].dest_rel // \"extra\"" "$PLAN_FILE")
            MAX_MB=$(jq -r ".plans[$i].max_mb // 100" "$PLAN_FILE")
            INCLUDE_ISO=$(jq -r ".plans[$i].include_in_iso // true" "$PLAN_FILE")
            REQUIRED=$(jq -r ".plans[$i].required // false" "$PLAN_FILE")
            mapfile -t INCLUDES < <(jq -r ".plans[$i].include_globs[]?" "$PLAN_FILE")
            mapfile -t EXCLUDES < <(jq -r ".plans[$i].exclude_globs[]?" "$PLAN_FILE")

            # Í≤ΩÎ°ú Ìï¥ÏÑù: repo-root ‚Üí package-root ‚Üí literal/absolute
            RESOLVED_SRC=""
            if [[ "$SRC" == /* ]]; then
              [[ -d "$SRC" ]] && RESOLVED_SRC="$SRC"
            else
              [[ -d "$GITHUB_WORKSPACE/$SRC" ]] && RESOLVED_SRC="$GITHUB_WORKSPACE/$SRC"
              [[ -z "$RESOLVED_SRC" && -d "$DEST_BASE/$SRC" ]] && RESOLVED_SRC="$DEST_BASE/$SRC"
              [[ -z "$RESOLVED_SRC" && -d "$SRC" ]] && RESOLVED_SRC="$SRC"
            fi

            if [[ -z "$RESOLVED_SRC" ]]; then
              if [[ "$REQUIRED" == "true" ]]; then
                fail "Plan[$i] required=true but src not found: $SRC (tried: $GITHUB_WORKSPACE/$SRC , $DEST_BASE/$SRC , $SRC)"
                exit 1
              else
                warn "Plan[$i] SRC not found: $SRC ‚Äî skipping (set required=true to fail)"
                continue
              fi
            fi

            DEST_DIR="$DEST_BASE/$DEST_REL"
            mkdir -p "$DEST_DIR"

            logf "Plan[$i] SRC=$SRC ‚Üí RESOLVED=$RESOLVED_SRC DEST_REL=$DEST_REL MAX_MB=${MAX_MB}MB INCLUDE_ISO=$INCLUDE_ISO REQUIRED=$REQUIRED"

            RSYNC_ARGS=(-a --delete --prune-empty-dirs)
            for p in "${INCLUDES[@]}";  do RSYNC_ARGS+=(--include "$p"); done
            for p in "${EXCLUDES[@]}";  do RSYNC_ARGS+=(--exclude "$p"); done
            RSYNC_ARGS+=(--exclude '.git/' --exclude '.github/')
            RSYNC_ARGS+=(--include '*/' --exclude '*')

            TMP_STAGE="$(mktemp -d)"
            rsync "${RSYNC_ARGS[@]}" "$RESOLVED_SRC/" "$TMP_STAGE/"

            TOTAL_BYTES=$(du -sb "$TMP_STAGE" | awk '{print $1}')
            LIMIT_BYTES=$((MAX_MB * 1024 * 1024))

            if (( TOTAL_BYTES > LIMIT_BYTES )); then
              warn "Plan[$i] size exceed: $(nf "$TOTAL_BYTES") > $(nf "$LIMIT_BYTES"). Truncating by newest-first copy."
              mkdir -p "$DEST_DIR"; REMAIN=$LIMIT_BYTES
              mapfile -t FILES < <(find "$TMP_STAGE" -type f -printf '%T@ %p\n' | sort -nr | awk '{sub($1 FS,""); print}')
              for f in "${FILES[@]}"; do
                sz=$(stat -c%s "$f"); (( sz <= REMAIN )) || continue
                rel="${f#"$TMP_STAGE/"}"
                mkdir -p "$DEST_DIR/$(dirname "$rel")"
                cp -a "$f" "$DEST_DIR/$rel"
                REMAIN=$((REMAIN - sz))
              done
            else
              rsync -a --delete "$TMP_STAGE/" "$DEST_DIR/"
            fi

            if [[ -d "$DEST_DIR" ]]; then
              while IFS= read -r -d '' f; do
                rel="${f#"$DEST_BASE/"}"
                bytes=$(stat -c%s "$f")
                sha=$(sha256sum "$f" | awk '{print $1}')
                printf '%s,%s,%s,%s,%s\n' "$SRC" "$RESOLVED_SRC" "$DEST_REL" "${rel#"$DEST_REL/"}" "$bytes" "$sha" >> "$MANIFEST_CSV"
              done < <(find "$DEST_DIR" -type f -print0)
            fi

            rm -rf "$TMP_STAGE"

            if [[ "$INCLUDE_ISO" == "true" ]]; then
              echo "include_in_iso=true" > "$DEST_DIR/.iso.include"
            else
              echo "include_in_iso=false" > "$DEST_DIR/.iso.include"
            fi

            logf "Plan[$i] done ‚Üí $DEST_DIR"
          done

          logf "Manifest generated: $MANIFEST_CSV"

      - name: Optional Docker build + save
        if: ${{ inputs.build_docker == true }}
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          IMG="${{ steps.parse.outputs.image_name }}:${{ steps.parse.outputs.image_tag }}"
          logf "Building Docker image: $IMG"
          docker build -t "$IMG" "$ROOT"
          mkdir -p artifacts
          docker save "$IMG" | gzip -c > "artifacts/${{ steps.parse.outputs.image_name }}-${{ steps.parse.outputs.image_tag }}.tar.gz"
          logf "Saved image tar.gz under artifacts/"

      - name: Prepare ISO staging & info injection (includes copied data + server scripts)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          STAGE="iso_stage/${P}"
          mkdir -p "$STAGE/config" "$STAGE/pkg" "$STAGE/docs" "$STAGE/extra" "$STAGE/server"

          echo "${{ github.repository }},${{ github.run_id }},${{ github.ref_name }}" > "$STAGE/build_info.csv"
          printf '%s' '${{ inputs.inject_info_json }}' | jq . > "$STAGE/config/inject.json"
          cp -a "$ROOT/dist" "$STAGE/pkg/"
          cp -a .github/echo_logs "$STAGE/docs/" || true
          cp -a "$ROOT/echo_mass/perm_apply.sh" "$STAGE/docs/" || true
          [[ -d "$ROOT/extra_manifests" ]] && cp -a "$ROOT/extra_manifests" "$STAGE/docs/" || true
          cp -a "$ROOT/server" "$STAGE/"

          # include_in_iso=true ÎßàÏª§ ÎåÄÏÉÅÎßå ISO Î∞òÏòÅ (STAGE/extra/)
          if [[ -d "$ROOT" ]]; then
            while IFS= read -r -d '' marker; do
              d="$(dirname "$marker")"
              rel="${d#"$ROOT/"}"
              mkdir -p "$STAGE/extra/$rel"
              rsync -a "$d/" "$STAGE/extra/$rel/"
            done < <(find "$ROOT" -type f -name ".iso.include" -print0 | xargs -0 grep -l "include_in_iso=true" || true)
          fi

          cat > "$STAGE/README.txt" <<'TXT'
          Echo ISO ‚Äî includes:
          - pkg/dist: built wheels/sdists or conda env pack
          - config/inject.json: injected metadata
          - docs/echo_logs: run logs
          - docs/perm_apply.sh: permission script
          - docs/extra_manifests: copy-plan manifest & checksums
          - extra/*: directories copied per copy_plan (include_in_iso=true)
          - server/*: install_deploy.sh & systemd unit template (generated)
          TXT

          logf "ISO staging prepared at $STAGE"

      - name: Build ISO (xorriso / genisoimage fallback)
        shell: bash
        run: |
          set -Eeuo pipefail
          ISO_NAME="${{ inputs.package_name }}-${{ inputs.package_version }}.iso"
          LABEL="${{ inputs.iso_label }}"
          STAGE="iso_stage/${{ inputs.package_name }}"
          mkdir -p artifacts
          if command -v xorriso >/dev/null 2>&1; then
            logf "Using xorriso"
            xorriso -as mkisofs -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          else
            logf "Using genisoimage"
            genisoimage -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          fi
          (cd artifacts && sha256sum "${ISO_NAME}" > "${ISO_NAME}.sha256" )
          logf "ISO built: artifacts/${ISO_NAME}"

      # === (ÏòµÏÖò) GHCR / Docker Hub Ìë∏Ïãú ===
      - name: Push image to GHCR
        if: ${{ inputs.build_docker && steps.parse.outputs.ghcr_enable == 'true' }}
        shell: bash
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          SRC_IMG="${{ steps.parse.outputs.image_name }}:${{ steps.parse.outputs.image_tag }}"
          DEST_REPO="${{ steps.parse.outputs.ghcr_repo }}"
          DEST_TAG="${{ steps.parse.outputs.ghcr_tag }}"
          [[ -z "$DEST_REPO" ]] && { warn "ghcr.repo empty, skip"; exit 0; }
          [[ -z "$DEST_TAG"  ]] && DEST_TAG="${{ steps.parse.outputs.image_tag }}"
          docker login ghcr.io -u ${{ github.actor }} -p "$CR_PAT"
          docker tag "$SRC_IMG" "$DEST_REPO:$DEST_TAG"
          docker push "$DEST_REPO:$DEST_TAG"
          logf "Pushed to GHCR: $DEST_REPO:$DEST_TAG"

      - name: Push image to Docker Hub
        if: ${{ inputs.build_docker && steps.parse.outputs.dh_enable == 'true' }}
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          SRC_IMG="${{ steps.parse.outputs.image_name }}:${{ steps.parse.outputs.image_tag }}"
          DEST_REPO="${{ steps.parse.outputs.dh_repo }}"
          DEST_TAG="${{ steps.parse.outputs.dh_tag }}"
          [[ -z "$DOCKERHUB_USERNAME" || -z "$DOCKERHUB_TOKEN" ]] && { fail "Docker Hub creds missing"; exit 1; }
          [[ -z "$DEST_REPO" ]] && { warn "dockerhub.repo empty, skip"; exit 0; }
          [[ -z "$DEST_TAG"  ]] && DEST_TAG="${{ steps.parse.outputs.image_tag }}"
          echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
          docker tag "$SRC_IMG" "$DEST_REPO:$DEST_TAG"
          docker push "$DEST_REPO:$DEST_TAG"
          logf "Pushed to Docker Hub: $DEST_REPO:$DEST_TAG"

      # === (ÏòµÏÖò) GitHub Release ÏÉùÏÑ± + ISO/Ïù¥ÎØ∏ÏßÄ ÏïÑÌã∞Ìå©Ìä∏ Ï≤®Î∂Ä ===
      - name: Create GitHub Release
        if: ${{ steps.parse.outputs.rel_enable == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.parse.outputs.rel_tag }}
          draft: ${{ steps.parse.outputs.rel_draft }}
          prerelease: ${{ steps.parse.outputs.rel_prerelease }}
          files: |
            artifacts/*.iso
            artifacts/*.sha256
            artifacts/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # === (ÏòµÏÖò) ÏÑúÎ≤Ñ Î∞∞Ìè¨ (SSH) ===
      - name: Deploy to server via SSH (optional)
        if: ${{ steps.parse.outputs.dep_enable == 'true' }}
        shell: bash
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_KEY }}
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          HOST="${{ steps.parse.outputs.dep_host }}"
          USER="${{ steps.parse.outputs.dep_user }}"
          PORT="${{ steps.parse.outputs.dep_port }}"
          DEST="${{ steps.parse.outputs.dep_path }}"
          SVC="${{ steps.parse.outputs.dep_svc }}"
          CMD="${{ steps.parse.outputs.dep_cmd }}"
          USE_SUDO="${{ steps.parse.outputs.dep_sudo }}"
          [[ -z "$SSH_PRIVATE_KEY" ]] && { fail "SERVER_SSH_KEY secret missing"; exit 1; }

          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh -o StrictHostKeyChecking=no -p "$PORT" "$USER@$HOST" "mkdir -p $DEST"

          # rsync ÏΩîÎìú Ï†ÑÏÜ°
          rsync -az -e "ssh -p $PORT -o StrictHostKeyChecking=no" "$ROOT/" "$USER@$HOST:$DEST/"

          # ÏõêÍ≤© ÏÑ§Ïπò Ïã§Ìñâ
          SUDO_FLAG=""
          [[ "$USE_SUDO" == "true" ]] && SUDO_FLAG="SUDO=sudo"
          ssh -o StrictHostKeyChecking=no -p "$PORT" "$USER@$HOST" \
            "cd $DEST && $SUDO_FLAG APP_NAME=${P} DEPLOY_PATH=$DEST START_CMD='$CMD' bash ./server/install_deploy.sh"

          logf "Deployed to $USER@$HOST:$DEST"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: echo-image-iso-${{ github.run_id }}
          path: |
            artifacts/**
            workspace/**/dist/**
            .github/echo_logs/**
          if-no-files-found: warn
