name: "🐍 PyPkg + Echo Dirs + Perm/Echo Files + Docker Image + ISO (All-in-One)"

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "파이썬 패키지 이름 (PEP 8 소문자, 하이픈/점 금지)"
        required: true
        default: "mypkg"
      package_version:
        description: "패키지 버전"
        required: true
        default: "0.1.0"
      dirs_count:
        description: "대량 생성 디렉토리 개수 (예: 2000)"
        required: true
        default: "500"
      iso_label:
        description: "ISO 볼륨 라벨(영문/숫자/언더스코어)"
        required: true
        default: "ECHO_ISO"
      inject_info_json:
        description: "ISO에 주입할 JSON(예: {\"env\":\"prod\",\"team\":\"devops\"})"
        required: false
        default: "{\"env\":\"dev\",\"team\":\"finops\"}"
      metadata_json:
        description: "패키지 메타(JSON): {\"author_name\":\"...\",\"author_email\":\"...\",\"license_name\":\"MIT\"}"
        required: false
        default: "{\"author_name\":\"Your Name\",\"author_email\":\"you@example.com\",\"license_name\":\"MIT\"}"
      image_ref:
        description: "Docker 이미지 참조(이름:태그), 예: mypkg-app:latest"
        required: true
        default: "mypkg-app:latest"
      build_docker:
        description: "Docker 이미지 빌드/저장 수행"
        required: true
        type: boolean
        default: true

permissions:
  contents: write
  actions: read

env:
  TZ: Asia/Seoul
  LOG_DIR: .github/echo_logs
  ECHO_OK: "✅"
  ECHO_WARN: "⚠️"
  ECHO_FAIL: "❌"
  DOCKER_BUILDKIT: "1"

jobs:
  all-in-one:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ★ 수정: 현재 스텝 즉시 + 다음 스텝 자동 로드 (BASH_ENV 이중 적용)
      - name: Global echo helpers (persist across steps)
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > "$GITHUB_WORKSPACE/.bashenv" <<'SH'
          ECHO_OK="${ECHO_OK:-✅}"
          ECHO_WARN="${ECHO_WARN:-⚠️}"
          ECHO_FAIL="${ECHO_FAIL:-❌}"
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"
          mkdir -p "$LOG_DIR"
          SAFE_LOG="${SAFE_LOG:-${LOG_DIR}/run-$(date +%Y%m%d%H%M%S).log}"
          echoe(){ printf '%s %s\n' "${ECHO_OK}" "$*"; }
          warn(){  printf '%s %s\n' "${ECHO_WARN}" "$*"; }
          fail(){  printf '%s %s\n' "${ECHO_FAIL}" "$*"; }
          logf(){  printf '%s\n' "$*" | tee -a "$SAFE_LOG"; }
          SH

          # 1) 현재 스텝에 즉시 적용
          export BASH_ENV="$GITHUB_WORKSPACE/.bashenv"
          # 2) 다음 스텝에도 자동 적용
          echo "BASH_ENV=$BASH_ENV" >> "$GITHUB_ENV"

          # 스모크 테스트 (이 스텝에서도 바로 동작해야 함)
          bash -lc 'echoe "helpers loaded"; logf "helpers ready"'

      - name: Install toolchain (Python, build tools, ISO tools)
        shell: bash
        run: |
          set -Eeuo pipefail
          logf "Installing build tools"
          sudo apt-get update -y
          sudo apt-get install -y python3 python3-venv python3-pip python3-setuptools python3-wheel \
              git jq xorriso genisoimage dosfstools
          python3 --version | tee -a "$LOG_DIR/python.txt"
          pip3 --version | tee -a "$LOG_DIR/pip.txt"
          logf "Installed: xorriso/genisoimage for ISO, jq for JSON"

      - name: Parse inputs (metadata_json, image_ref)
        id: parse
        shell: bash
        run: |
          set -Eeuo pipefail
          MJ='${{ inputs.metadata_json }}'
          A_NAME=$(printf '%s' "$MJ" | jq -r '.author_name // "Your Name"')
          A_EMAIL=$(printf '%s' "$MJ" | jq -r '.author_email // "you@example.com"')
          L_NAME=$(printf '%s' "$MJ" | jq -r '.license_name // "MIT"')

          IMG='${{ inputs.image_ref }}'
          if [[ "$IMG" == *:* ]]; then
            IMG_NAME="${IMG%%:*}"
            IMG_TAG="${IMG##*:}"
          else
            IMG_NAME="$IMG"
            IMG_TAG="latest"
          fi

          {
            echo "author_name=$A_NAME"
            echo "author_email=$A_EMAIL"
            echo "license_name=$L_NAME"
            echo "image_name=$IMG_NAME"
            echo "image_tag=$IMG_TAG"
          } | tee -a "$LOG_DIR/parsed_inputs.env"

          echo "author_name=$A_NAME"   >> "$GITHUB_OUTPUT"
          echo "author_email=$A_EMAIL" >> "$GITHUB_OUTPUT"
          echo "license_name=$L_NAME"  >> "$GITHUB_OUTPUT"
          echo "image_name=$IMG_NAME"  >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMG_TAG"    >> "$GITHUB_OUTPUT"

      - name: Create Python package skeleton (PEP 621 / pyproject.toml)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          V="${{ inputs.package_version }}"
          A="${{ steps.parse.outputs.author_name }}"
          E="${{ steps.parse.outputs.author_email }}"
          L="${{ steps.parse.outputs.license_name }}"
          ROOT="workspace/${P}"
          PKG_DIR="$ROOT/src/${P}"
          TEST_DIR="$ROOT/tests"
          DOC_DIR="$ROOT/docs"
          mkdir -p "$PKG_DIR" "$TEST_DIR" "$DOC_DIR"

          # core files (safe heredoc)
          cat > "$ROOT/pyproject.toml" <<'PYT'
          [build-system]
          requires = ["setuptools>=68", "wheel"]
          build-backend = "setuptools.build_meta"

          [project]
          name = "__PKG_NAME__"
          version = "__PKG_VER__"
          description = "Auto-generated package with EchoOps"
          authors = [{ name="__AUTHOR__", email="__EMAIL__"}]
          license = { text="__LICENSE__" }
          readme = "README.md"
          requires-python = ">=3.9"
          classifiers = [
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License"
          ]

          [project.urls]
          Homepage = "https://example.com"

          [tool.setuptools.packages.find]
          where = ["src"]
          PYT
          sed -i "s/__PKG_NAME__/${P}/g" "$ROOT/pyproject.toml"
          sed -i "s/__PKG_VER__/${V}/g" "$ROOT/pyproject.toml"
          sed -i "s/__AUTHOR__/${A}/g" "$ROOT/pyproject.toml"
          sed -i "s/__EMAIL__/${E}/g" "$ROOT/pyproject.toml"
          sed -i "s/__LICENSE__/${L}/g" "$ROOT/pyproject.toml"

          cat > "$ROOT/README.md" <<'MD'
          # Auto Generated Python Package
          - EchoOps generated.
          - Includes Dockerfile and ISO injection artifacts.
          MD

          cat > "$PKG_DIR/__init__.py" <<'PY'
          __all__ = ["hello"]
          __version__ = "__VER__"
          def hello(name: str = "World") -> str:
              return f"Hello, {name}!"
          PY
          sed -i "s/__VER__/${V}/g" "$PKG_DIR/__init__.py"

          cat > "$TEST_DIR/test_hello.py" <<'PY'
          from __future__ import annotations
          from __pkg__.__init__ import hello
          def test_hello():
              assert hello("Echo") == "Hello, Echo!"
          PY
          sed -i "s/__pkg__/${P}/g" "$TEST_DIR/test_hello.py"

          # minimal Dockerfile
          cat > "$ROOT/Dockerfile" <<'DOCKER'
          FROM python:3.11-slim
          WORKDIR /app
          COPY . /app
          RUN pip install --no-cache-dir .
          CMD ["python","-c","import __PKG__; print(__PKG__.hello('Docker'))"]
          DOCKER
          sed -i "s/__PKG__/${P}/g" "$ROOT/Dockerfile"

          logf "Python skeleton created at $ROOT"

      - name: Build wheel / sdist
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          python3 -m pip install --upgrade pip build
          python3 -m build "$ROOT"
          ls -al "$ROOT/dist" | tee -a "$LOG_DIR/dist.txt"

      - name: Massive directory generation (+ echo-style permission files)
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          COUNT="${{ inputs.dirs_count }}"
          BASE="workspace/${P}/echo_mass"
          mkdir -p "$BASE"

          # echo-style script that grants perms and writes logs per dir
          cat > "$BASE/perm_apply.sh" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          LOG_DIR="${LOG_DIR:-.github/echo_logs}"
          mkdir -p "$LOG_DIR"
          OUT="$LOG_DIR/perm-$(date +%Y%m%d%H%M%S).log"
          echo "perm started: $(date)" | tee -a "$OUT"
          for d in "$@"; do
            mkdir -p "$d"
            chmod 755 "$d"
            printf 'ECHO %s %s\n' "$(date +%Y-%m-%dT%H:%M:%S)" "$d" | tee -a "$OUT"
            echo "ok" > "$d/.echo.ok"
          done
          echo "done: $(date)" | tee -a "$OUT"
          SH
          chmod +x "$BASE/perm_apply.sh"

          # generate N dirs and apply
          mapfile -t DLIST < <(seq -w 1 "$COUNT" | xargs -I{} echo "$BASE/dir_{}")
          "${BASE}/perm_apply.sh" "${DLIST[@]}"
          logf "Generated $COUNT directories with permission echoes."

      - name: Optional Docker build + save
        if: ${{ inputs.build_docker == true }}
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          IMG="${{ steps.parse.outputs.image_name }}:${{ steps.parse.outputs.image_tag }}"
          logf "Building Docker image: $IMG"
          docker build -t "$IMG" "$ROOT"
          mkdir -p artifacts
          docker save "$IMG" | gzip -c > "artifacts/${{ steps.parse.outputs.image_name }}-${{ steps.parse.outputs.image_tag }}.tar.gz"
          logf "Saved image tar.gz under artifacts/"

      - name: Prepare ISO staging & info injection
        shell: bash
        run: |
          set -Eeuo pipefail
          P="${{ inputs.package_name }}"
          ROOT="workspace/${P}"
          STAGE="iso_stage/${P}"
          mkdir -p "$STAGE/config" "$STAGE/pkg" "$STAGE/docs"

          # Inject build metadata
          echo "${{ github.repository }},${{ github.run_id }},${{ github.ref_name }}" > "$STAGE/build_info.csv"

          # Inject user JSON info
          printf '%s' '${{ inputs.inject_info_json }}' | jq . > "$STAGE/config/inject.json"

          # Include built distributions
          cp -a "$ROOT/dist" "$STAGE/pkg/"

          # Include echo logs & permission script
          cp -a .github/echo_logs "$STAGE/docs/" || true
          cp -a "$ROOT/echo_mass/perm_apply.sh" "$STAGE/docs/" || true

          # README
          cat > "$STAGE/README.txt" <<'TXT'
          Echo ISO — contains:
          - pkg/dist: built wheels/sdists
          - config/inject.json: injected metadata
          - docs/echo_logs: run logs
          - docs/perm_apply.sh: permission script
          TXT

          logf "ISO staging prepared at $STAGE"

      - name: Build ISO (xorriso / genisoimage fallback)
        shell: bash
        run: |
          set -Eeuo pipefail
          ISO_NAME="${{ inputs.package_name }}-${{ inputs.package_version }}.iso"
          LABEL="${{ inputs.iso_label }}"
          STAGE="iso_stage/${{ inputs.package_name }}"
          mkdir -p artifacts
          if command -v xorriso >/dev/null 2>&1; then
            logf "Using xorriso"
            xorriso -as mkisofs -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          else
            logf "Using genisoimage"
            genisoimage -R -J -V "$LABEL" -o "artifacts/${ISO_NAME}" "$STAGE"
          fi
          (cd artifacts && sha256sum "${ISO_NAME}" > "${ISO_NAME}.sha256" )
          logf "ISO built: artifacts/${ISO_NAME}"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: echo-image-iso-${{ github.run_id }}
          path: |
            artifacts/**
            workspace/**/dist/**
            .github/echo_logs/**
          if-no-files-found: warn
